<!--
An ordered sequence of elements which can be navigated through one at a time.
-->

<Control className="Sequence" generic="true">

<script>
Sequence.prototype.extend({
    
    /*
     * The currently visible element. The getter returns the element as an
     * instance of the appropriate control class.
     */
    activeElement: Control.iterator( function( activeElement ) {
        if ( activeElement === undefined ) {
            return this.elements().filter( ".active" ).eq(0).cast( jQuery );
        } else {
            
            /*
             * Apply a "inactive" style instead of just forcing display to none.
             * If we did that, we would have no good way to undo the hiding.
             * A simple .toggle(true) would set display: block, which wouldn't
             * be what we'd want for inline elements.
             */
            this.elements().not( activeElement )
                .addClass( "inactive" )
                .removeClass( "active" );

            var index = this.elements().index( activeElement );

            // Tell the child it's now active, and show it.
            $( activeElement )
                .trigger( "active" )
                .removeClass( "inactive" )
                .addClass( "active" );
            
            this
                // Trigger our own activeElementChanged event.
                .trigger( "activeElementChanged", [ index, activeElement ] )
            
                // In case the new child changed our size.
                .checkForSizeChange();
            
            return this;
        }
    }),
    
    /*
     * The index of the currently visible element.
     */
    activeIndex: function( index ) {
        if ( index === undefined ) {
            return this.elements().index( this.activeElement() );
        } else {
            return this.activeElement( this.elements().eq( index ) );
        }
    },
    
    /*
     * The array of elements in the sequence; only one will be shown at a time.
     * 
     * If the set changes, this will attempt to preserve the one that was
     * previously active. Otherwise, the first element is made active.
     */
    content: function( value ) {
        
        var previousControl = this.activeElement();
        var container = this._container();
        var result = ( this[0] === container[0] )
            ? this._super( value )
            : container.content( value );
        
        
        if ( value !== undefined ) {
            if ( previousControl && previousControl.parent()[0] === this[0] ) {
                // Still have previously active child; hide other elements.
                this.activeElement( previousControl );
            } else {
                this.activeIndex( 0 );
            }
        }
        
        return result;
    },

    /*
     * The set of elements in the sequence.
     */
    elements: Control.chain( "_container", "children", "cast" ),
    
    initialize: function() {
        if ( this.activeIndex() < 0 ) {
            // Show first child by default. 
            this.activeIndex(0);
        }
    },

    /*
     * Show the next child. If the last child is currently shown, this has no
     * effect.
     */
    next: Control.iterator( function() {
        var index = this.activeIndex();
        if ( index < this.elements().length - 1 ) {
            this.activeIndex( index + 1 );
        }
    }),

    /*
     * Show the previous child. If the first child is currently shown, this has
     * no effect.
     */
    previous: Control.iterator( function() {
        var index = this.activeIndex();
        if ( index > 0 ) {
            this.activeIndex( index - 1 );
        }
    }),

    _container: function() {
        return this;
    }

});
</script>

</Control>