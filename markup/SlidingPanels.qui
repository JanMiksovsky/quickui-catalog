<!--
Display children as elements on a sliding horizontal strip; only one element
is visible at a time. The strip can be programmatically slid left and right.
-->
<Control className="SlidingPanels">

<prototype>
    <Sequence>
        <div ref="SlidingPanels_content"/>
    </Sequence>
</prototype>

<style>
{
    -moz-box-sizing: border-box;
    box-sizing: border-box;
    overflow: hidden;
    width: 0; /* Prevent anything from appearing until we've set width. */
}

.SlidingPanels_content {
    position: relative; /* So we can shift it over */
    -webkit-transition: 0.2s;
    transition: 0.2s; /* Same as jQuery's "fast" */
    white-space: nowrap;
}
.SlidingPanels_content > * {
    display: inline-block;
}
</style>

<script>
SlidingPanels.prototype.extend({
    
    /*
     * The index of the control currently being shown.
     */
    activeIndex: function( activeIndex ) {
        var result = this._super( activeIndex );
        if ( activeIndex !== undefined ) {
            var panel = this.elements().eq( activeIndex );
            if ( panel.length > 0 ) {
                var left = panel.position().left;
                if ( SlidingPanels.hasTransitions( this.$SlidingPanels_content() ) ) {
                    // Use CSS animation.
                    this.$SlidingPanels_content().css( "left", -left );
                }
                else {
                    // Fall back to jQuery animation.
                    this.$SlidingPanels_content().animate({
                        "left": -left
                    }, "fast" );
                }
            }            
        }
        return result;
    },

    /*
     * The array of elements in the sequence; only one will be shown at a time.
     * 
     * If the set changes, this will attempt to preserve the one that was
     * previously active. Otherwise, the first element is made active.
     */
    content: function( content ) {
        var result = this._super( content );
        if ( content !== undefined ) {
            this._adjustWidths();
        }
        return result;
    },
    
    initialize: function() {
        var self = this;
        this
            .inDocument( function() {
                this._adjustWidths();
            })
            .on( "layout sizeChanged", function() {
                self._adjustWidths();
            });
    },
    
    // Force all elements and the control itself to the maximium width of the elements.
    _adjustWidths: function() {

        var elements = this.elements();
        if ( elements.length === 0 ) {
            return;
        }
        
        var panelWidths = elements.map( function( index, panel ) {
            return $( panel ).width();
        }).get();
        var maxpanelWidth = Math.max.apply( this, panelWidths );
        if ( maxpanelWidth > 0 ) {
            elements.width( maxpanelWidth );
        }

        var panelOuterWidths = elements.map( function( index, panel ) {
            return $( panel ).outerWidth( true );
        }).get();
        var maxpanelOuterWidth = Math.max.apply( this, panelOuterWidths );
        if ( maxpanelOuterWidth > 0 ) {
            this.width( maxpanelOuterWidth );
        }
    },

    _container: Control.chain( "$SlidingPanels_content" )
    
});

/*
 * Class methods
 */
SlidingPanels.extend({

    /*
     * Returns true if the given element has CSS transitions applied to it.
     */
    hasTransitions: function( $element ) {
        transitionProperties = [
            "-webkit-transition",
            "transition"
        ];
        // HACK for IE8, in which jQuery 1.7.2 will throw an exception if we
        // try to get the css("transition") property.
        if ( $.browser.msie && parseInt( $.browser.version ) < 9 ) {
            return false;
        }
        for ( var i = 0; i < transitionProperties.length; i++ ) {
            var value = $element.css( transitionProperties[i] );
            if ( value !== undefined && value !== "" ) {
                return true;
            }
        }
        return false;
    }

})
</script>

</Control>
