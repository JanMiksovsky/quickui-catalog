<!--
A set of tabbed pages.

Each child of the content will be treated as a page. If the child has a function
called description(), that will be used as the name on the tab.

The Tabs control will resize itself to be as tall as its tallest child.
-->

<Control className="Tabs" generic="true">

<content>
    <VerticalPanels ref="tabPanels">
        <top>
            <List ref="tabButtons" itemClass="BasicButton" />
        </top>
        <Modes ref="Tabs_content" maximize="true" />
    </VerticalPanels>
</content>

<style>
{
    position: relative;
}

.tabButtons {
    white-space: nowrap; /* So tabs don't wrap. */
}

/* Generic appearance */
.Tabs.generic .Tabs_content {
    border: 1px solid #888;
    height: 100%;
}
.Tabs.generic .tabButtons {
    position: relative;
    top: 1px;
    z-index: 1;
}
.Tabs.generic .tabButtons .BasicButton.generic {
    background: none;
    border-color: #bbb;
    border-bottom-color: transparent;
    border-bottom-left-radius: 0;
    border-bottom-right-radius: 0;
    color: #444;
    filter: none;
    margin-right: 0.25em;
    outline: none;
}
.Tabs.generic .tabButtons .BasicButton.generic.selected {
    border-color: #888;
    border-bottom-color: white;
    color: inherit;
}
</style>

<script>
Tabs.prototype.extend({
    
    /*
     * The array of elements to be shown as tabs.
     */
    content: Control.chain( "$Tabs_content", "content", function() {
        this._createButtons();
    }),

    contentClass: function( contentClass ) {
        if ( contentClass === undefined ) {
            return this.$Tabs_content().controlClass();
        } else {
            // The default Modes class sets the content's size, so clear any
            // explicitly-set height and width.
            this.$Tabs_content().css({
                height: "",
                width: ""
            });
            var $new = this.$Tabs_content().transmute( contentClass, true );
            this.referencedElement( "Tabs_content", $new );
            this.$Tabs_content().checkForSizeChange();
            return this;
        }
    },

    /*
     * True if the Tabs should vertically fill its container.
     */    
    fill: Control.chain( "$tabPanels", "fill" ),
    
    initialize: function() {

        var self = this;
        this.$tabButtons().click( function( event ) {
            var tabButtonCssClass = "." + self.tabButtonClass().prototype.className;
            var tabButton = $( event.target ).closest( tabButtonCssClass ).control();
            if ( tabButton ) {
                var index = self.tabButtons().index( tabButton );
                if ( index >= 0 ) {
                    var tab = self.tabs()[ index ];
                    self.trigger( "tabButtonClick", [ index, tab ]);
                    if ( self.selectTabOnClick() ) {
                        self.selectedTabIndex( index );
                    }
                }
            }
        });
        
        this.$Tabs_content().on({
            "activeElementChanged": function( event, index, child ) {
                /*
                 * Map the Modes's activeElementChanged event to a more
                 * semantically specific activeTabChanged event.
                 * 
                 * Only map active events coming from our own Modes; ignore
                 * events coming from any Modes within a tab.
                 */
                var tab = $( event.target ).filter( self.tabs() );
                if ( tab.length > 0 ) {
                    event.stopPropagation();
                    self.trigger( "activeTabChanged", [ index, child ] );
                }
            }
        });
        
        if ( this.tabs().length > 0 && !this.selectedTabIndex() ) {
            // Select first tab by default.
            this.selectedTabIndex(0);
        }
    },
    
    /*
     * True if a tab should be selected on click; false if the showing of the
     * clicked tab will be handled separately. 
     */
    selectTabOnClick: Control.property.bool( null, true ),

    /*
     * The child currently shown as the selected tab.
     */
    selectedTab: Control.chain( "$Tabs_content", "activeChild" ),
    
    /*
     * The index of the selected tab.
     */
    selectedTabIndex: Control.chain( "$Tabs_content", "activeIndex", function( index ) {
        this.tabButtons()
            .removeClass( "selected" )    // Deselect all tab buttons.
            .eq( index )
            .addClass( "selected" );      // Select the indicated button.
    }),

    /*
     * The current set of tab button controls.
     */
    tabButtons: Control.chain( "$tabButtons", "children" ),
    
    /*
     * The class which should be used to create tab buttons for the set.
     */
    tabButtonClass: Control.chain( "$tabButtons", "itemClass", function() {
        this._createButtons();
    }),
    
    /*
     * The content of the current set of tabs.
     */
    tabs: Control.chain( "$Tabs_content", "elements" ),

    /*
     * Called whenever the set of buttons needs to be regenerated.
     */
    _createButtons: function() {
        
        if ( this.tabButtonClass() === undefined ) {
            return;
        }
        
        // Show the description for each tab as a button.
        var descriptions = this.tabs()
            .map( function( index, tab ) {
                var $tab = $( tab ).control();
                var description = ( $tab && $.isFunction( $tab.description ) )
                        ? $tab.description()
                        : "";
                return description;
            })
            .get();
            
        this.$tabButtons().items( descriptions );
        
        var selectedTabIndex = this.selectedTabIndex(); 
        if ( selectedTabIndex != null ) {
            // Ensure the indicated button is shown as selected.
            this.selectedTabIndex( selectedTabIndex );
        }
    }

});
</script>

</Control>
