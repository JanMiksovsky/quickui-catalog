<!--
Renders a list of items in a combo box.

The user can type arbitrary text; if they type the beginning of a list item's
content, the remainder of the item's content is AutoCompleted. For this to
work, both the control's content and the content of the list items should
be strings.
-->

<Control name="ListComboBox">

<prototype>
    <ComboBox>
        <popup>
            <ListBox id="list"/>
        </popup>
    </ComboBox>
</prototype>

<style>
#list {
    border: none;
}
#list > * {
    display: block;
}

/* Generic appearance */
.ListComboBox.generic .ButtonBase {
    border: none;
}
</style>

<script>
ListComboBox.prototype.extend({
    
    _itemContents: Control.property(),
    items: Control.chain( "$list", "items", function() { this._updateItemContents(); } ),
    mapFunction: Control.chain( "$list", "mapFunction" ),
    _timeout: Control.property(),
    
    initialize: function() {
        
        this._super();
        this.genericIfClassIs( ListComboBox );
        
        // Clicking an item in the list puts its content into the text box portion.
        var self = this;
        this.$list()
            .click( function( event ) {
                var $closestItem = $( event.target ).closest( self.$list().children() );
                if ( $closestItem ) {
                    var itemContent = $closestItem.control().content();
                    self
                        .content( itemContent )
                        .close();
                }
            })
            .on( "selectionChanged", function() {
                var selectedControl = self.$list().selectedControl();
                if ( selectedControl ) {
                    var content = selectedControl.content();
                    if ( content !== self.content() ) {
                        self.content( content );
                        self._selectText( 0, content.length );
                    }
                }
            })
            .on( "keydown", function( event ) {
                if ( event.which === 13 /* Enter */) {
                    if ( self.opened() ) {
                        self.close();
                        event.stopPropagation();
                        event.preventDefault();
                    }
                }
            });
        
        if ( !this.itemClass() ) {
             this.itemClass( ButtonBase );
        }
    },
    
    // Instead of chaining, make this a property so we can check for a default
    // value of undefined.
    itemClass: Control.property[ "class" ]( function( itemClass ) {
        this.$list().itemClass( itemClass );
    }),
    
    open: function() {

        // See if current text is in the list and, if so, select it.
        var content = this.content();
        var index = $.inArray( content, this._itemContents() );
        if ( index >= 0 ) {
            this.$list().selectedIndex( index );
        }
        
        return this._super();
    },
    
    // Try to auto-complete the current text against the item contents.
    _autoComplete: function() {
        
        var content = this.content();
        // console.log( content );
        
        var match = this._matchingItem( content );
        if ( !match ) {
            this.$list().selectedControl( null );
            return;
        }

        this.content( match );
        
        // Select the auto-completed text.
        this._selectText( content.length, match.length );
        
        if ( this.opened() ) {
            // Select the match in the list if it's there
            var index = $.inArray( match, this._itemContents() );
            this.$list().selectedIndex( index );
        }
    },
    
    _bindContentEvents: function() {
        
        this._super();
        
        // See notes at _contentKeydown.
        var self = this;
        this.inputControl().keydown( function( event ) {
            self._contentKeydown( event );
        });
    },
    
    /*
     * Handle a keydown event. Keydown gives the best AutoComplete performance
     * and behavior: among other things, the AutoComplete happens as soon as
     * the user begins typing. However, using keydown creates a problem that
     * the input control's content won't actually reflect the effects key the
     * user just pressed down. So we set a timeout to give the keydown event a
     * chance to bubble up and do its work, then do our AutoComplete work
     * against the resulting text.
     */
    _contentKeydown: function( event ) {
        
        var handled = false;
        var navigationKeys = [
            33, // Page Up
            34, // Page Down
            38, // Up
            40 // Down
        ];
        
        // Do AutoComplete on space or characters from zero digit (0) and up,
        // ignoring any combinations that involve Alt or Ctrl.
        if ( (event.which === 32 || event.which >= 48 ) 
            && !( event.altKey || event.ctrlKey || event.metaKey) ) {

            this._setAutoCompleteTimeout();
            
        } else if ( this.opened() && $.inArray( event.which, navigationKeys ) >= 0 ) {
            
            // Forward navigation keys to opened list.
            this.$list().trigger( event );
            handled = true;

        } else if ( event.which === 40 ) {
            
            // Pressing down when list is closed will open list.
            this.open();
            
            // If the input text is empty, select the first list item.
            var content = this.content();
            if ( content == null || content.length === 0 ) {
                this.$list().selectedIndex( 0 );
            }

            handled = true;
            
        }
        
        if ( handled ) {
            event.stopPropagation();
            event.preventDefault();
        }
    },

    // Return the item whose prefix matches the given string, ignoring case.
    // Return null if not found.
    _matchingItem: function( s ) {
        var length = s.length;
        if ( length > 0 ) {
            var lower = s.toLowerCase();
            var itemContents = this._itemContents();
            for ( var i = 0, itemCount = itemContents.length; i < itemCount; i++ ) {
                var itemContent = itemContents[i]; 
                if ( length <= itemContent.length
                    && itemContent.substr( 0, length ).toLowerCase() === lower ) {
                    return itemContent;
                }
            }
        }
        return null;
    },
    
    // Arrange for AutoComplete to be performed via a timeout.
    // See notes at _contentKeydown.
    _setAutoCompleteTimeout: function() {
        
        // Cancel any pending AutoComplete timeout.
        var timeout = this._timeout();
        if ( timeout ) {
            clearTimeout( timeout );
        }
        
        // Queue a new AutoComplete timeout.
        var self = this;
        timeout = window.setTimeout( function() {
            self._autoComplete();
        }, 50 );
        this._timeout( timeout );
    },
    
    /*
     * Extract a copy of all the items so we can match against them when
     * the user types. We get the contents from the list's controls, rather
     * than from the list's items() property, since the items could be
     * arbitrary JavaScript objects. Once the list's mapFunction has mapped
     * those objects into the controls, the controls' content should best
     * reflect the text to map against. 
     */
    _updateItemContents: function() {
        var itemContents = [];
        this.$list().controls().eachControl( function( index, $control ) {
            itemContents.push( $control.content() );
        });
        this._itemContents( itemContents );
    }

});
</script>

</Control>
