<!--
Renders a list of items in a combo box.

The user can type arbitrary text; if they type the beginning of a list item's
content, the remainder of the item's content is AutoCompleted. For this to
work, both the control's content and the content of the list items should
be strings.
-->

<Control name="ListComboBox">

<prototype>
    <ComboBox>
        <popup>
            <List id="list"/>
        </popup>
    </ComboBox>
</prototype>

<style>
#list > * {
    display: block;
}

/* Generic appearance */
.ListComboBox.generic .ButtonBase {
    border: none;
}
</style>

<script>
ListComboBox.prototype.extend({
    
    _itemContents: Control.property(),
    items: Control.chain( "$list", "items", function() { this._updateItemContents(); } ),
    mapFunction: Control.chain( "$list", "mapFunction" ),
    _timeout: Control.property(),
    
    initialize: function() {
        
        this._super();
        this.genericIfClassIs( ListComboBox );
        
        var self = this;
        
        // See notes at _handleKeydown.
        this.$ComboBox_content().keydown( function( event ) {
            self._handleKeydown( event );
        });
        
        // Clicking an item in the list puts its content into the text box portion.
        this.$list().click( function( event ) {
            var $closestItem = $( event.target ).closest( self.$list().children() );
            if ( $closestItem ) {
                var itemContent = $closestItem.control().content();
                self
                    .content( itemContent )
                    .close();
            }
        });
        
        if ( !this.itemClass() ) {
             this.itemClass( ButtonBase );
        }
    },
    
    // Instead of chaining, make this a property so we can check for a default
    // value of undefined.
    itemClass: Control.property[ "class" ]( function( itemClass ) {
        this.$list().itemClass( itemClass );
    }),
    
    // Try to auto-complete the current text against the item contents.
    _autoComplete: function() {
        
        var content = this.content();
        // console.log( content );
        
        var match = this._matchingItem( content );
        if ( !match ) {
            return;
        }

        this.content( match );
        
        // Select the auto-completed text.
        this._selectText( content.length, match.length );
    },
    
    /*
     * Handle a keydown event. Keydown gives the best AutoComplete performance
     * and behavior: among other things, the AutoComplete happens as soon as
     * the user begins typing. However, using keydown creates a problem that
     * the input control's content won't actually reflect the effects key the
     * user just pressed down. So we set a timeout to give the keydown event a
     * chance to bubble up and do its work, then do our AutoComplete work
     * against the resulting text.
     */
    _handleKeydown: function( event ) {
        
        // Ignore key codes which aren't characters.
        if ( event.which < 46 && event.which !== 32 /* Space */ ) {
            return;
        }
            
        // Cancel any pending AutoComplete timeout.
        var timeout = this._timeout();
        if ( timeout ) {
            clearTimeout( timeout );
        }
        
        // Queue a new AutoComplete timeout.
        var self = this;
        timeout = window.setTimeout( function() {
            self._autoComplete();
        }, 50 );
        this._timeout( timeout );
    },

    // Return the item whose prefix matches the given string, ignoring case.
    // Return null if not found.
    _matchingItem: function( s ) {
        var length = s.length;
        if ( length > 0 ) {
            var lower = s.toLowerCase();
            var itemContents = this._itemContents();
            for ( var i = 0, itemCount = itemContents.length; i < itemCount; i++ ) {
                var itemContent = itemContents[i]; 
                if ( length <= itemContent.length
                    && itemContent.substr( 0, length ).toLowerCase() === lower ) {
                    return itemContent;
                }
            }
        }
        return null;
    },

    /*
     * Select the text at the indicated positions in the input control.
     */
    _selectText: function( start, end ) {
        
        var inputControl = this.inputControl()[0];
        if ( !inputControl ) {
            return; // Can't find input control.
        }
        
        if ( inputControl.createTextRange ) {
            var range = inputControl.createTextRange();
            range.moveStart( "character", start );
            range.moveEnd( "character", end );
            range.select();
        } else if ( inputControl.setSelectionRange ) {
            // Firefox
            inputControl.setSelectionRange( start, end );
        }
    },
    
    /*
     * Return the start and end position of the text currently selected in the
     * input control.
     */
    _selection: function() {
        
        var inputControl = this.inputControl()[0];
        if ( !inputControl ) {
            return; // Can't find input control.
        }
        
        var selectionStart;
        if ( inputControl.selectionStart ) {
            // Firefox
            selectionStart = inputControl.selectionStart;
        } else if ( document.selection ) {
            // Solution from
            // http://the-stickman.com/web-development/javascript/finding-selection-cursor-position-in-a-textarea-in-internet-explorer/
            var range = document.selection.createRange();
            var rangeCopy = range.duplicate();
            rangeCopy.moveToElementText( inputControl );
            rangeCopy.setEndPoint( "EndToEnd", range );
            selectionStart = rangeCopy.text.length - range.text.length;
        }
        
        return selectionStart;
    },
    
    /*
     * Extract a copy of all the items so we can match against them when
     * the user types. We get the contents from the list's controls, rather
     * than from the list's items() property, since the items could be
     * arbitrary JavaScript objects. Once the list's mapFunction has mapped
     * those objects into the controls, the controls' content should best
     * reflect the text to map against. 
     */
    _updateItemContents: function() {
        var itemContents = [];
        this.$list().controls().eachControl( function( index, $control ) {
            itemContents.push( $control.content() );
        });
        this._itemContents( itemContents );
    }

});
</script>

</Control>
