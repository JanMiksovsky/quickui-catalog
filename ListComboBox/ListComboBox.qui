<!--
Renders a list of items in a combo box.

The user can type arbitrary text; if they type the beginning of a list item's
content, the remainder of the item's content is AutoCompleted. For this to
work, both the control's content and the content of the list items should
be strings.
-->

<Control name="ListComboBox">

<prototype>
    <ComboBox>
        <popup>
            <ListBox id="list"/>
        </popup>
    </ComboBox>
</prototype>

<style>
#list {
    border: none;
}
#list > * {
    display: block;
}

/* Generic appearance */
.ListComboBox.generic .ButtonBase {
    border: none;
}
</style>

<script>
ListComboBox.prototype.extend({
    
    _itemContents: Control.property(),
    items: Control.chain( "$list", "items", function() { this._updateItemContents(); } ),
    mapFunction: Control.chain( "$list", "mapFunction" ),
    _timeout: Control.property(),
    
    initialize: function() {
        
        this._super();
        this.genericIfClassIs( ListComboBox );
        
        // Clicking an item in the list puts its content into the text box portion.
        var self = this;
        this.$list()
            .click( function( event ) {
                var $closestItem = $( event.target ).closest( self.$list().children() );
                if ( $closestItem ) {
                    var itemContent = $closestItem.control().content();
                    self
                        .content( itemContent )
                        .close();
                }
            })
            .on( "selectionChanged", function() {
                var selectedControl = self.$list().selectedControl();
                if ( selectedControl ) {
                    var content = selectedControl.content();
                    self.content( content );
                }
            })
            .on( "keydown", function( event ) {
                if ( event.which === 13 /* Enter */) {
                    if ( self.opened() ) {
                        self.close();
                        event.stopPropagation();
                        event.preventDefault();
                    }
                }
            });
        
        if ( !this.itemClass() ) {
             this.itemClass( ButtonBase );
        }
    },
    
    // Instead of chaining, make this a property so we can check for a default
    // value of undefined.
    itemClass: Control.property[ "class" ]( function( itemClass ) {
        this.$list().itemClass( itemClass );
    }),
    
    open: function() {

        // See if current text is in the list and, if found, select it.
        var content = this.content();
        var index = $.inArray( content, this._itemContents() );
        if ( index < 0 ) {
            // Not found; select the first item instead.
            index = 0;
        }
        this.$list().selectedIndex( index );
        
        return this._super();
    },
    
    // Try to auto-complete the current text against the item contents.
    _autoComplete: function() {
        
        var content = this.content();
        // console.log( content );
        
        var match = this._matchingItem( content );
        if ( !match ) {
            return;
        }

        this.content( match );
        
        // Select the auto-completed text.
        this._selectText( content.length, match.length );
    },
    
    _bindContentEvents: function() {
        
        this._super();
        
        // See notes at _contentKeydown.
        var self = this;
        this.inputControl().keydown( function( event ) {
            self._contentKeydown( event );
        });
    },
    
    /*
     * Handle a keydown event. Keydown gives the best AutoComplete performance
     * and behavior: among other things, the AutoComplete happens as soon as
     * the user begins typing. However, using keydown creates a problem that
     * the input control's content won't actually reflect the effects key the
     * user just pressed down. So we set a timeout to give the keydown event a
     * chance to bubble up and do its work, then do our AutoComplete work
     * against the resulting text.
     */
    _contentKeydown: function( event ) {
        
        var handled = false;
        switch ( event.which ) {
            
            case 32: // Space
                break;
                
            case 40: // Down
                this.open();
                this.$list().focus();
                handled = true;
                break;
                
            default:
                // Ignore other key codes which aren't characters.
                if ( event.which <= 46 ) {
                    return;
                }
                break;
        }
        
        if ( handled ) {
            event.stopPropagation();
            event.preventDefault();
            return;
        }
            
        // Cancel any pending AutoComplete timeout.
        var timeout = this._timeout();
        if ( timeout ) {
            clearTimeout( timeout );
        }
        
        // Queue a new AutoComplete timeout.
        var self = this;
        timeout = window.setTimeout( function() {
            self._autoComplete();
        }, 50 );
        this._timeout( timeout );
    },

    // Return the item whose prefix matches the given string, ignoring case.
    // Return null if not found.
    _matchingItem: function( s ) {
        var length = s.length;
        if ( length > 0 ) {
            var lower = s.toLowerCase();
            var itemContents = this._itemContents();
            for ( var i = 0, itemCount = itemContents.length; i < itemCount; i++ ) {
                var itemContent = itemContents[i]; 
                if ( length <= itemContent.length
                    && itemContent.substr( 0, length ).toLowerCase() === lower ) {
                    return itemContent;
                }
            }
        }
        return null;
    },
    
    /*
     * Extract a copy of all the items so we can match against them when
     * the user types. We get the contents from the list's controls, rather
     * than from the list's items() property, since the items could be
     * arbitrary JavaScript objects. Once the list's mapFunction has mapped
     * those objects into the controls, the controls' content should best
     * reflect the text to map against. 
     */
    _updateItemContents: function() {
        var itemContents = [];
        this.$list().controls().eachControl( function( index, $control ) {
            itemContents.push( $control.content() );
        });
        this._itemContents( itemContents );
    }

});
</script>

</Control>
