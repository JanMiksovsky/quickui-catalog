<!--
Apply effects on hover, which can include changing the item's size
and position.

To animate color properties, use a plugin such as Color Animation at
http://plugins.jquery.com/project/color-animation.
-->

<Control className="HighlightEffects">

<content>
    <div id="HighlightEffects_content"/>
</content>

<style>
{
    -moz-box-sizing: border-box;
    -ms-box-sizing: border-box;
    -webkit-box-sizing: border-box;
    box-sizing: border-box;
    position: relative;
    -webkit-tap-highlight-color: rgba(0, 0, 0, 0); /* No tap highlight */
}
</style>

<script>
HighlightEffects.prototype.extend({
    
    _originalState: Control.property(),
    
    /*
     * The control's content.
     */
    content: Control.chain( "$HighlightEffects_content", "content", function() {
        if ( this.inDocument() ) {
            this._recalc();
        }
    }),
    
    /*
     * The speed with which animations are applied.
     * 
     * This uses a faster default than $.animate(), since hover animations
     * should generally respond quickly.
     * 
     * Set this to 0 to have effects applied instantaneously.
     */
    duration: Control.property( null, 100 ),
    
    /*
     * The effects that will be applied on hover.
     */
    effects: Control.property( function() {
        this._originalState( this._getCurrentState() );
    }),
    
    initialize: function() {
        
        this.genericIfClassIs( HighlightEffects );

        var self = this;
        this
            .bind( "sizeChanged", function() {
                self._recalc();
            })
            .hover(
                function() { self._hoverIn(); },
                function() { self._hoverOut(); }
            )
            .inDocument( function( $control ) {
                $control
                    ._originalState( $control._getCurrentState() )
                    ._recalc();
            });
    },

    /*
     * Get the current values of all CSS attributes which will be overwritten
     * by the effects. This snapshot is used on hover out to restore the
     * original state.
     */
    _getCurrentState: function() {
        var currentState = {};
        var $content = this.$HighlightEffects_content();
        var effects = this.effects();
        for ( var key in effects ) {
            var value;
            switch ( key ) {

                /*
                 * When border properties are applied, they may get split up
                 * into border-<side> properties, leaving the overall border
                 * properties empty. So, use the properties of one of the
                 * border sides as a proxy for the overall border properties.
                 */
                case "border-color":
                    value = $content.css( "border-top-color" );
                    break;
                case "border-width":
                    value = $content.css( "border-top-width" );
                    break;
                
                /*
                 * Map dimensions of "auto" to "0" so that the dimension can
                 * be animated. 
                 */
                case "bottom":
                case "left":
                case "right":
                case "top":
                    value = $content.css( key );
                    if ( value === "auto" ) {
                        value = "0";
                    }
                    break;
                    
                default:
                    value = $content.css( key );
                    break;
            }
            currentState[ key ] = value;
        }
        return currentState;
    },

    _hoverIn: function() {
        this.$HighlightEffects_content()
            .stop() // In case this was doing its _hoverOut animation
            .css({
                "position": "absolute",
                "z-index": "2"  // In front of any element doing _hoverOut
            })
            .animate( this.effects(), this.duration() );
    },
    
    _hoverOut: function() {
        var savedState = this._originalState() || {};
        this.$HighlightEffects_content()
            .stop() // In case this was doing its _hoverIn animation
            .css({
                // Show in front of peer elements, but behind _hoverIn element.
                "z-index": "1" 
            })
            .animate( savedState, this.duration(), null, function() {
                // Restore normal positioning when animation completes.
                $( this ).css({
                    "position": "inherit",
                    "z-index": "inherit"
                });
            });
    },
    
    /*
     * Update the control's size to match the contents. This lets us
     * apply absolute positioning to the contents on hover while still
     * preserving room for the content in the normal document flow.
     */
    _recalc: function() {
        this.height( this.$HighlightEffects_content().outerHeight() );
        this.width( this.$HighlightEffects_content().outerWidth() );
    }
    
});
</script>

</Control>
