<!--
Fades its content to the background color on the right/bottom edge if the
content is too long. Must set explicitly set the control's background-color
if the color is not white. 
-->

<Control className="Fader">

<prototype>
    <Control class="horizontal">
        <div ref="Fader_content"/>
        <Gradient ref="gradient" direction="horizontal" />
    </Control>
</prototype>

<style>
{
    background-color: #ffffff;
    overflow: hidden;
    position: relative;
}

.Fader_content {
    white-space: nowrap;
}

.Fader.vertical .Fader_content {
    white-space: inherit;
}

.gradient {
    position: absolute;
}
.Fader.horizontal .gradient {
    height: 100%;
    right: 0;
    top: 0;
    width: 1.5em;
}
.Fader.vertical .gradient {
    bottom: 0;
    height: 1.5em;
    width: 100%;
}
</style>

<script>
Fader.prototype.extend({
    
    content: Control.chain( "$Fader_content", "content" ),
    
    /*
     * The direction in which the content should fade. If "horizontal" (the
     * default), the content will fade to the right. If "vertical", the content
     * will fade to the bottom.
     */
    direction: Control.property( function( direction ) {
        var vertical = ( direction !== "horizontal" );
        this
            .toggleClass( "horizontal", !vertical )
            .toggleClass( "vertical", vertical );
        if ( this.inDocument() ) {
            this._redraw();
        }
        this.$gradient().direction(direction);
    }),
    
    initialize: function() {
        this.inDocument( function() {
            this._redraw();
        });
    },
    
    // Expand a color like #abc into #aabbcc.
    _expandShortHexValue: function( s ) {
        var shortHex = s.slice( 1 ); // Remove "#"
        var longHex = "";
        for ( var i = 0; i < shortHex.length; i++ ) {
            var c = shortHex[i];
            longHex += c + c;
        }
        return "#" + longHex;
    },

    _hexByte: function( n ) {
        var s = ( new Number( n & 0xFF ) ).toString( 16 );
        if ( s.length === 1 )
        {
            s = "0" + s;
        }
        return s;
    },
    
    _redraw: Control.iterator( function() {
        var backgroundColor = this.css("background-color");
        var backgroundHex = ( backgroundColor.length === 4 )
            ? this._expandShortHexValue( backgroundColor ) 
            : ( backgroundColor.substr( 0, 3 ).toLowerCase() === "rgb" )
                ? this._rgbStringToHexColor( backgroundColor )
                : backgroundColor;
        this.$gradient()
            .start( backgroundHex + "00" )
            .end( backgroundHex );
    }),
    
    _rgbStringToHexColor: function( rgbString ) {
        rgb = rgbString.match(/^rgb\((\d+),\s*(\d+),\s*(\d+)\)$/);
        return "#"
            + this._hexByte( rgb[1] )
            + this._hexByte( rgb[2] )
            + this._hexByte( rgb[3] );
    }
    
});
</script>

</Control>
