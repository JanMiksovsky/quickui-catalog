<!--
A list box that allows single selection.
The user can select an item with the mouse or keyboard.
-->

<Control className="ListBox" generic="true">

<prototype>
    <List itemClass="BasicButton" />
</prototype>

<style>
{
    overflow-y: auto;
}

> * {
    display: block;
    outline: none;
}

/* Generic appearance */
.ListBox.generic {
    border: 1px solid lightgray;
    -moz-box-sizing: border-box;
    box-sizing: border-box;
}

/* Handle common case where a button is used as a list item. */
.ListBox.generic > .BasicButton.generic {
    border: none;
    width: 100%;
}
.ListBox.generic > .BasicButton.generic.selected {
    background: highlight;
    color: highlighttext;
}
</style>

<script>
ListBox.prototype.extend({
  
    /*
     * True if clicking on the list background (if there aren't enough
     * items to fill the list's available space) will deselect the
     * currently-selected item. Default is true.
     */
    deselectOnBackgroundClick: Control.property.bool( null, true ),
    
    initialize: function() {
        
        this._super();
        
        /*
         * Try to convince the browser that the list is focusable, but without
         * forcing it into the tab order (as a positive tabindex would do).
         * Firefox, Chrome, and IE seem to handle this as desired if tabindex
         * is set to a negative number.
         */
        this.attr( "tabindex", "-1" );
        
        var self = this;
        this.on({
            click: function( event ) {
                if ( event.target === self[0] ) {
                    /* User clicked the list box's background. */
                    if ( self.deselectOnBackgroundClick() ) {
                        self.selectedControl( null );
                    }
                } else {
                    var control = self._getControlContainingElement( event.target );
                    if ( control ) {
                        self._controlClick( control );
                    }
                }
            },
            keydown: function( event ) {
                self._keydown( event );
            }
        });
    },
    
    /*
     * The array of items shown in the list box.
     */
    items: function( value ) {
        /* Preserve selection index when items change */ 
        var previousIndex = this.selectedIndex();
        var result = this._super( value );
        if ( value !== undefined && value.length > 0 ) {
            var index = ( previousIndex >= 0 && previousIndex < value.length )
                ? previousIndex     // Restore previous selection.
                : -1;               // Nothing will be selected.
            this.selectedIndex( index );
        }
        return result;
    },
    
    /*
     * Toggles the selected state of a control in the list.
     * 
     * If the select parameter is true, this applies the "selected" class to the
     * control, which the list uses to track which control is selected. If the
     * control supports a selected() function, that will be invoked as well.
     * Subclasses can perform additional manipulations here.
     */
    selectControl: function( control, select ) {
        control.toggleClass( "selected", select );
        if ( $.isFunction( control.selected ) ) {
            control.selected( select );
        }
    },
    
    /*
     * The control in the list which is currently selected.
     */
    selectedControl: Control.iterator( function( selectedControl ) {
        if ( selectedControl === undefined ) {
            var control = this.controls().filter( ".selected" ).eq(0);
            return control.length > 0
                ? control
                : null;
        } else {
            var previousControl = this.selectedControl();
            var selectedElement = selectedControl ? selectedControl[0] : null;
            var self = this;
            this.controls().eachControl( function( index, control) {
                self.selectControl( control, control[0] === selectedElement );
            });
            if ( selectedControl ) {
                this._scrollToControl( selectedControl );
            }
            if ( selectedControl !== previousControl ) {
                this.trigger( "selectionChanged" );
            }
        }
    }),
    
    /*
     * The index of the currently-selected control.
     */
    selectedIndex: Control.iterator( function( selectedIndex ) {
        if ( selectedIndex === undefined ) {
            var control = this.selectedControl();
            return control
                ? this.controls().index( control )
                : -1;
        } else {
            var index = parseInt( selectedIndex );
            var control = ( index >= 0 )
                ? this.controls().eq( index )
                : null;
            this.selectedControl( control );
        }
    }),
    
    /*
     * The item represented by the currently-selected control.
     */
    selectedItem: Control.iterator( function( selectedItem ) {
        if ( selectedItem === undefined ) {
            var index = this.selectedIndex();
            return index >= 0
                ? this.items()[ index ]
                : null;
        } else {
            var index = $.inArray( selectedItem, this.items() );
            this.selectedIndex( index );
        }
    }),
    
    _controlClick: function( control ) {
        this.selectedControl( control );
    },
    
    _getControlContainingElement: function( element ) {
        return $( element ).closest( this.controls() ).control();
    },
    
    /*
     * Return the control that spans the given y position, or -1 if not found.
     * If downward is true, move down the list of controls to find the
     * first control found at the given y position; if downward is false,
     * move up the list of controls to find the last control at that position. 
     */
    _getControlAtY: function( y, downward ) {
        
        var controls = this.controls();
        var start = downward ? 0 : controls.length - 1;
        var end = downward ? controls.length : 0;
        var step = downward ? 1 : -1;
        for ( var i = start; i !== end; i += step ) {
            var $control = controls.eq(i);
            var controlTop = Math.round( $control.offset().top );
            var controlBottom = controlTop + $control.outerHeight();
            if ( controlTop <= y && controlBottom >= y ) {
                return i;
            }
        }
        
        return -1;
    },
    
    /*
     * Handle a keydown event.
     */
    _keydown: function( event ) {
        
        var handled;
        switch ( event.which ) {

            case 33: // Page Up
                handled = this._pageUp();
                break;
                
            case 34: // Page Down
                handled = this._pageDown();
                break;
            
            case 35: // End
                handled = this._selectLastControl();
                break;
            
            case 36: // Home
                handled = this._selectFirstControl();
                break;
            
            case 38: // Up
                handled = event.altKey
                    ? this._selectFirstControl()
                    : this._selectPreviousControl();
                break;
                
            case 40: // Down
                handled = event.altKey
                    ? this._selectLastControl()
                    : this._selectNextControl();
                break;
                
            default:
                handled = false;
                break;
        }
        
        if (handled)
        {
            event.stopPropagation();
            event.preventDefault();
        }
    },
    
    _pageDown: function() {
        return this._scrollOnePage( true );
    },
    
    _pageUp: function() {
        return this._scrollOnePage( false );
    },
    
    /*
     * Move by one page downward (if downward is true), or upward (if false).
     */
    _scrollOnePage: function( downward ) {

        var selectedIndex = this.selectedIndex();
        
        // Find the control at the bottom/top edge of the viewport.
        var viewPortDimensions = this._viewPortDimensions();
        var edge = downward ? viewPortDimensions.bottom : viewPortDimensions.top;
        var index = this._getControlAtY( edge, downward );
        
        if ( index >= 0 && selectedIndex === index ) {
            // The control at that edge is already selected.
            // Move one page further down/up.
            var delta = downward
                ? viewPortDimensions.height
                : -viewPortDimensions.height; 
            index = this._getControlAtY( edge + delta, downward );
        }

        if ( index < 0 ) {
            // Would have scrolled too far in that direction.
            // Just select the last/first control.
            index = downward
                ? this.controls().length - 1
                : 0;
        }
        
        if ( index !== this.selectedIndex() ) {
            this.selectedIndex( index );
            return true;
        }
        
        return false;
    },
    
    /*
     * Scroll the given control into view.
     */
    _scrollToControl: function( $control ) {
        
        var controlTop = $control.offset().top;
        var controlBottom = controlTop + $control.outerHeight();

        var viewPortDimensions = this._viewPortDimensions();
        var scrollTop = this.scrollTop();
        
        if ( controlBottom > viewPortDimensions.bottom ) {
            // Scroll up until control is entirely visible.
            this.scrollTop( scrollTop + controlBottom - viewPortDimensions.bottom );
        } else if ( controlTop < viewPortDimensions.top ) {
            // Scroll down until control is entirely visible.
            this.scrollTop( scrollTop - ( viewPortDimensions.top - controlTop ) );
        }
    },
    
    _selectFirstControl: function() {
        if ( this.controls().length > 0 ) {
            this.selectedIndex( 0 );
            return true;
        }
        return false;
    },
    
    _selectLastControl: function() {
        if ( this.controls().length > 0 ) {
            this.selectedIndex( this.controls().length - 1 );
            return true;
        }
        return false;
    },
    
    _selectNextControl: function() {
        var index = this.selectedIndex() + 1;
        if ( index < this.controls().length ) {
            this.selectedIndex( index );
            return true;
        }
        return false;
    },
    
    _selectPreviousControl: function() {
        var index = this.selectedIndex() - 1;
        if ( index >= 0 && this.controls().length > 0 ) {
            this.selectedIndex( index );
            return true;
        }
        return false;
    },
    
    _viewPortDimensions: function() {
        var viewPortTop = this.offset().top;
        var viewPortHeight = this.height();
        return {
            top: viewPortTop,
            height: viewPortHeight,
            bottom: viewPortTop + viewPortHeight
        };
    }
    
});
</script>

</Control>
