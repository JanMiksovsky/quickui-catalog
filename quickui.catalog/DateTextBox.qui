<!--
Text box that parses dates.
If Globalize is installed, all of the current culture's local date formats are
supported, plus modified short date formats that permit a missing year or two-
digit year. If Globalize is not installed, a default date parser is used.
-->

<Control className="DateTextBox">

<prototype>
    <ValidatingTextBox/>
</prototype>

<style>
{
    width: 6em;
}
</style>

<script>
DateTextBox.prototype.extend({

    /*
     * The control's current culture.
     */
    culture: function( culture ) {
        var result = this._super( culture );
        if ( culture !== undefined ) {
            this._updateDatePatterns();
            this._refresh();
        }
        return result;
    },

    /*
     * The date indicated in the text box.
     */
    date: Control.property.date( function( date ) {
        var previousDate = this._previousDate();
        var previousTime = previousDate && previousDate.getTime();
        var time = date && date.getTime();
        var dateChanged = ( previousTime !== time ); 
        if ( dateChanged ) {
            
            var hasFocus = $.contains( this[0], document.activeElement );
            if ( !hasFocus ) {
                // We updating the content only if the user isn't typing,
                // so as not to confuse them.
                this._refresh();
            }
            
            this
                ._previousDate( date )
                .trigger( "dateChanged", [ date ] );
        }
    }),
    
    initialize: function() {
        
        this._super();
        this.genericIfClassIs( DateTextBox );
        
        var self = this;
        this.blur( function() {
            self._refresh();
        });
        
        this._updateDatePatterns();
    },
    
    /*
     * Returns true if the current date is valid. 
     */
    valid: function() {

        var valid = this._super();

        // Convert content text to a date.
        var content = this.content();
        var date = this._parseDate( content );
        this.date( date );

        // If a date is supplied, it has to be valid.
        if ( content && content.length > 0 ) {
            valid = valid && !!date;
        }
        
        return valid;
    },
    
    /*
     * Use a culture's "short date" pattern (e.g., "M/d/yyyy") to determine
     * some abbreviated date patterns.
     * 
     * The first abbreviated pattern uses a short two-digit year ("M/d/yy")
     * instead of a full four-digit year. The second pattern omits the year
     * ("M/d"). These patterns are determined by looking for a full year
     * placeholder ("yyyy") and the culture's date separator ("/") immediately
     * before or after the year.
     */
    _abbreviatedDatePatterns: function( culture ) {
        
        var patterns = [];
        var calendar = culture.calendar;
        var shortPattern = calendar.patterns.d;
        var fullYearPlaceholder = "yyyy";
        
        // Try replacing full four-digit year with short two-digit year.
        if ( shortPattern.indexOf ( fullYearPlaceholder ) ) {
            patterns.push( shortPattern.replace( fullYearPlaceholder, "yy" ));
        }
        
        // Try removing separator + year, then try removing year + separator.
        var separator = calendar[ "/" ];
        var separatorThenYear = separator + fullYearPlaceholder;
        var yearThenSeparator = fullYearPlaceholder + separator;
        if ( shortPattern.indexOf( separatorThenYear ) >= 0 ) {
            patterns.push( shortPattern.replace( separatorThenYear, "" ) );
        } else if ( shortPattern.indexOf( yearThenSeparator ) >= 0 ) {
            patterns.push( shortPattern.replace( yearThenSeparator, "" ) );
        }
        
        return patterns;
    },
    
    _datePatterns: Control.property(),
    
    // Return the separator between dates.
    _dateSeparator: function() {
        var culture = this.culture();
        var calendar = culture ? culture.calendar : DateTextBox;
        return calendar[ "/" ];
    },
    
    _formatDate: function( date ) {
        var culture = this.culture();
        var formattedDate;
        if ( culture ) {
            formattedDate = Globalize.format( date, culture.calendar.patterns.d, culture );
        } else {
            formattedDate = (date.getMonth() + 1) + 
                this._dateSeparator() + date.getDate() +
                this._dateSeparator() + date.getFullYear();
        }
        return formattedDate;
    },

    /*
     * Parse the given text as a date.
     * Use the culture's parser if available, otherwise use a default parser.
     */
    _parseDate: function( text ) {
        var date = this.culture()
            ? Globalize.parseDate( text, this._datePatterns(), this.culture() )
            : this._parseDateDefault( text );
        return date;
    },
    
    /*
     * Basic date parser.
     * Parses the given text as a date and return the result.
     * Returns null if the text couldn't be parsed.
     * 
     * This handles the formats supported by the standard Date.parse(),
     * as well as handling a short year ("1/1/12") or missing year ("1/1").
     */
    _parseDateDefault: function( text ) {

        if ( text === "" ) {
            return null;
        }

        var dateSeparator = this._dateSeparator();
        var parts = text.split( dateSeparator );
        var currentYear = ( new Date() ).getFullYear().toString();
        
        var munged;
        if ( parts.length === 2 ) {
            // Add on year
            munged = text + dateSeparator + currentYear;
        } else if ( parts.length === 3 && parts[2].length == 2 ) {
            // Convert short year to long year
            var fullYear = currentYear.substring(0, 2) + parts[2];
            munged = parts[0] + dateSeparator
                   + parts[1] + dateSeparator
                   + fullYear;
        } else {
            // Parse as is
            munged = text;
        }
        
        var milliseconds = Date.parse( munged );
        var date = isNaN( milliseconds )
            ? null
            : new Date( milliseconds );
        return date;
    },
    
    _refresh: function() {
        var date = this.date();
        if ( !!date ) {
            var formattedDate = this._formatDate( date );
            if ( formattedDate !== this.content() ) {
                this.content( formattedDate );
            }
        }
        return this;
    },
    
    _previousDate: Control.property.date(),
    
    /*
     * If the culture's been set, we amend the list of support date patterns
     * to include some abbreviated patterns.
     */
    _updateDatePatterns: function() {
        var datePatterns = null;
        var culture = this.culture();
        if ( culture ) {
            // Update our date patterns based on the new culture.
            var abbreviatedDatePatterns = this._abbreviatedDatePatterns( culture );
            if ( abbreviatedDatePatterns.length > 0 ) {
                // Add our abbreviated patterns to all the culture's patterns.
                datePatterns = $.map( this.culture().calendar.patterns, function( pattern, name ) {
                    return pattern;
                });
                datePatterns = datePatterns.concat( abbreviatedDatePatterns );
            }
        }
        this._datePatterns( datePatterns );
    }
    
});

/*
 * Class properties.
 */
DateTextBox.extend({
    // Date separator, used when Globalize is not present.
	"/": "/"
});
</script>

</Control>
