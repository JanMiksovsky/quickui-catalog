<!--
An input area with a dropdown arrow, which invokes a popup.
-->

<Control className="ComboBox">

<prototype>
    <PopupSource closeOnInsideClick="false" openOnClick="false">
        <content>
            
            <div ref="ComboBox_content"/>
            
            <!--
            Negative tabindex prevents tabstop, which isn't necessary here
            as the text box portion will get the focus, and the user can
            invoke the popup from there. E.g., ListComboBox opens the popup
            when the Down key is pressed.
            TODO: Promote Down key behavior from ListComboBox to this class.
            -->
            <ToggleButton ref="dropdownButton" tabindex="-1">&#9660;</ToggleButton>

        </content>
    </PopupSource>
</prototype>

<style>
{
    display: inline-block;
}

.PopupSource_content {
    position: relative;
}

.PopupSource_popup {
    outline: none;
}

.ComboBox_content {
    margin-right: 1.5em; /* HACK to avoid overlapping button. Not general enough. */
}

.ComboBox_content[type='text'], .ComboBox_content input[type='text'] {
    border: none;
    -moz-box-sizing: border-box;
    box-sizing: border-box;
    outline: none;
    padding: 2px;
}

.dropdownButton {
    bottom: 0;
    height: 100%;
    outline: none;
    position: absolute;
    right: 0;
    text-align: center;
    top: 0;
}

/* Generic appearance */
.ComboBox.generic {
    border: 1px solid lightgray;
    -moz-box-sizing: border-box;
    box-sizing: border-box;
}
.ComboBox.generic .dropdownButton {
    border: none;
    border-left: 1px solid transparent;
    padding: 0 0.25em; /* Tighter padding that normal */
}
.ComboBox.generic:hover .dropdownButton {
    border-left-color: lightgray;
}
</style>

<script>
ComboBox.prototype.extend({

    /*
     * True if the dropdown portion should automatically close if the user
     * presses Enter. Default is true.
     */
    closeOnEnter: Control.property.bool( null, true ),
    
    /*
     * The content of the combo box's input portion.
     */
    content: Control.chain( "$ComboBox_content", "content" ),
    
    /*
     * The content of the dropdown button. By default, this shows a
     * downward-pointing arrow.
     */
    dropdownButtonContent: Control.chain( "$dropdownButton", "content" ),
    
    initialize: function() {
        
        this._super();
        this.genericIfClassIs( ComboBox );
        
        var self = this;
        this.$PopupSource_popup().on({
            "canceled": function() {
                self.$dropdownButton().selected( false );
            },
            "closed": function() {
                // Closing the popup leaves the text selected.
                // HACK for IE: If we set focus to the input while the popup is
                // being closed, IE won't hide the popup. It seems quite hard
                // to prevent this behavior, so we simply disable the selection
                // behavior in IE.
                if ( !$.browser.msie ) {
                    var content = self.content();
                    self.inputElement().focus();
                    self._selectText( 0, content.length );
                }
                self.$dropdownButton().selected( false );
            }
        });
        
        this.on({
            // Close the popup when the control loses focus.
            "focusout": function( event ) {
                /*
                 * We want to close the popup if the focus moves completely
                 * outside the combo box; i.e., is not within the input box or
                 * the popup. Unfortunately, if the user clicks in the popup,
                 * the input will blur before we've had a chance to even
                 * register the click. And at the point the blur handler here
                 * is invoked, the new activeElement is not yet known, so we
                 * can't test that.  
                 * 
                 * Our solution is to set a timeout which will defer testing
                 * of activeElement until after the normal focusout sequence
                 * has completed and focus has been placed in the new control.
                 */
                if ( self.opened() ) {
                    setTimeout( function() {
                        var focusInControl = $.contains( self[0], document.activeElement );
                        if ( !focusInControl && self.opened() ) { // Still open?
                            self.cancel();
                        }
                    }, 1);
                }
            }
        });
        
        this.$dropdownButton().click( function( event ) {
            self.open();
        });
        
        // Allow the popup container itself to receive the focus.
        // This allows clicks on the popup to still keep focus within the
        // overall ComboBox controls.
        this.$PopupSource_popup().prop( "tabindex", -1 );
       
        if ( !this.textBoxClass() ) {
            // Set a default text box class
            this.textBoxClass( TextBox );
        }
    },
    
    /*
     * Returns the combo box's input element. By default this is the content
     * element itself (if it's a text box) or else the first text input element
     * in the content. Subclasses can override this to indicate that a different
     * element should be used for input.
     */
    inputElement: function() {
        var $content = this.$ComboBox_content();
        if ( $content[0].nodeName.toLowerCase() === "input" && $content.prop( "type" ) === "text" ) {
            // Content itself is a text input element.
            return $content;
        }
        // Return the first text input element.
        return this.$ComboBox_content().find( "input[type='text']" ).eq(0);
    },
    
    /*
     * Open the combo box.
     */
    open: function() {
        if ( !this.opened() ) {
        
            if ( this.hasClass( "generic" ) ) {
                // Make popup at least as wide as content.
                this.eachControl( function( index, $control ) {
                    var width = $control.outerWidth();
                    this.$PopupSource_popup().css( "min-width", width + "px" );
                });
            }
            
            // User may have invoked popup by clicking in text box with
            // openOnFocus true, in which case we should ensure button looks
            // pressed while popup is open.
            this.$dropdownButton().selected( true );
            
        }
        return this._super();
    },

    /*
     * True if the control should automatically open when it receives the
     * keyboard focus. Default is true.
     */
    openOnFocus: Control.property.bool( null, true ),

    /*
     * The class of the text box portion of the combo box.
     */
    textBoxClass: Control.property[ "class" ]( function( textBoxClass ) {
        
        var $textBox = this.$ComboBox_content().transmute( textBoxClass, true );
        this.referencedElement( "$ComboBox_content", $textBox );
        
        // Rebind any content events we want to track.
        this._bindContentEvents();
    }),
    
    _bindContentEvents: function() {
        var self = this;
        this.$ComboBox_content().on({
            "click focusin": function( event ) {
                if ( self.openOnFocus() && !self.opened() ) {
                    self.open();
                }
            },
            "keydown": function( event ) {
                if ( event.which === 13 /* Enter key */
                    && self.closeOnEnter()
                    && self.$PopupSource_popup().opened() ) {
                    self.close();
                }
            }
        });
    },

    /*
     * Select the text at the indicated positions in the input control.
     */
    _selectText: function( start, end ) {
        
        var inputElement = this.inputElement()[0];
        if ( !inputElement ) {
            return; // Can't find input control.
        }
        
        if ( inputElement.setSelectionRange ) {
            // Mozilla/WebKit
            inputElement.setSelectionRange( start, end );
        } else if ( inputElement.createTextRange ) {
            // IE
            var range = inputElement.createTextRange();
            range.moveStart( "character", start );
            range.moveEnd( "character", end );
            range.select();
        }
    }

});
</script>

</Control>
