<!--
A panel that can be situated in a vertically scrolling container, and which
will move up and down in the viewport, but will bump up against the top of
the viewport and remain visible instead of scrolling out of view.

The control hosts its content within a panel that can pop out of the layout
flow. To faciliate styling, the control exposes background and padding
properties that map to the corresponding properties on this inner panel.
For most complex content styling, set all content elements within a single
div or other element and style that.

Note: A PersistentPanel should generally be placed within the highest-level
scrolling element on the page; it will not work property when placed
in a scrolling element nested within some outer scrolling element.
-->

<Control className="PersistentPanel">

<content>
    <div id="PersistentPanel_content"/>
</content>

<style>
{
    -moz-box-sizing: border-box;
    box-sizing: border-box;
}

#PersistentPanel_content {
    -moz-box-sizing: border-box;
    box-sizing: border-box;
}

.PersistentPanel.docked #PersistentPanel_content {
    position: fixed;
}

/* Generic appearance */
.PersistentPanel.generic #PersistentPanel_content {
    background: white;
    z-index: 1;
}
</style>

<script>
PersistentPanel.prototype.extend({

    /*
     * The content's background. See top notes.
     */    
    background: Control.chain( "$PersistentPanel_content", "css/background" ),
    
    /*
     * The control's content.
     */
    content: Control.chain( "$PersistentPanel_content", "content", function() {
        this.checkForSizeChange();
    }),
    
    /*
     * True if the control is currently docked to the top of the viewport.
     */
    docked: Control.chain( "applyClass/docked" ),
    
    initialize: function() {
        
        this.genericIfClassIs( PersistentPanel );
        
        var self = this;
        this
            .on( "layout", function() {
                if ( self.inDocument() ) {
                    self._recalc();
                }
            })
            .inDocument( function() {
                if ( !this.scrollingParent() ) {
                    // No scrolling parent has been set; look for one.
                    this.scrollingParent( this._findScrollingParent() );
                }
                this._recalc();
            });

        $( window ).resize( function() {
            self._recalc();
        });
    },
    
    /*
     * The content's padding. See top notes.
     */
    padding: Control.chain( "$PersistentPanel_content", "css/padding" ),
    
    /*
     * The parent of this control used to determine whether the control is
     * in or out of view. The default value for this property is the closest
     * parent element with overflow-y set to "auto" or "scroll".
     */
    scrollingParent: Control.property( function( scrollingParent ) {
        var self = this;
        $( scrollingParent ).scroll( function() {
            self._recalc();
        });
    }),

    _adjustSizes: function() {
        
        // Make the panel the same width as the container.
        this.$PersistentPanel_content().width( this.width() );
        
        // Make the container the same height as the panel, so that when
        // the panel pops out in fixed mode, the container can continue
        // to occupy the same amount of vertical space.
        this.height( this.$PersistentPanel_content().outerHeight( true ) );
    },
    
    /*
     * Determine which parent of the control scrolls vertically.
     */
    _findScrollingParent: function() {
        
        // By default, assume the window is what is scrolling.
        var scrollingParent = window;
        
        var parents = this.parents();
        for ( var i = 0; i < parents.length; i++ ) {
            
            if ( parents[i] === document.body ) {
                /*
                 * It doesn't appear possible to bind to the scroll event
                 * for the document body. Instead, if the body is the
                 * scrolling parent, we use the window instead, which has
                 * the same effect.
                 */
                break;
            }
            
            var overflowY = parents.eq(i).css( "overflow-y" );
            if ( overflowY === "auto" || overflowY === "scroll" ) {
                // Found a parent that explicitly asks for scrolling; use that.
                scrollingParent = parents[i];
                break;
            }
        }
        
        return scrollingParent;
    },

    /*
     * Do the real work of the control: determine whether the panel contents
     * should flow with the document, or pop out into a docked position at the
     * top or bottom of the viewport.
     */
    _recalc: function() {
        var scrollingParent = this.scrollingParent();
        if ( scrollingParent ) {
            
            var isScrollingParentWindow = ( scrollingParent === window );
            var $scrollingParent = $( scrollingParent );
            
            var scrollTop = $scrollingParent.scrollTop();
            var containerTop = this.position().top;
            var aboveViewPort = ( containerTop < scrollTop );

            var scrollBottom = scrollTop + $scrollingParent.height();
            var containerBottom = containerTop + this.height();
            var belowViewPort = ( containerBottom > scrollBottom );
            
            var dock = ( aboveViewPort || belowViewPort );

            if ( dock ) {
                /*
                 * Docking the content puts it outside the normal document.
                 * The control (the outer container) will collapse in size,
                 * which we don't want to happen -- anything below the control
                 * will suddenly jump in position. To ensure smooth movement,
                 * we force the control and content to match sizes.
                 * 
                 * We first set the content's width to match the container's
                 * width. This may cause the content to change in height.
                 * We then set the container's height to match the content's.
                 */
                this.$PersistentPanel_content().width( this.width() );
                this.height( this.$PersistentPanel_content().outerHeight( true ) );

                var css;
                var viewPortTop = isScrollingParentWindow
                    ? 0
                    : $scrollingParent.offset().top;
                if ( aboveViewPort ) {
                    css = { "top": viewPortTop + "px" };
                } else {
                    var viewPortBottom = isScrollingParentWindow
                        ? 0
                        : viewPortTop + $scrollingParent.height();
                    css = { "bottom": viewPortBottom };
                }
                this.$PersistentPanel_content().css( css );
                
            } else {
                // Reset any dimensions we set while docked.
                this.$PersistentPanel_content().css({
                    "bottom": "",
                    "top": "",
                    "width": ""
                });
                this.css( "height", "" );
            }
            
            this.docked( dock );
        }
    }
    
});
</script>

</Control>
