<!--
A control that covers the entire viewport, typically to swallow clicks.
-->

<Control className="Overlay">

<style>
{
    cursor: default;
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
}

/* TODO: Remove this test style */
{
    background: white;
    opacity: 0.5;
}

/* Generic appearance */
.Overlay.generic.modal {
    background: black;
    opacity: 0.25;
}
</style>

<script>
Overlay.prototype.extend({
    
    initialize: function() {
        this.genericIfClassIs( Overlay );
        
        var self = this;
        this.click( function( event ) {
            if ( self.modal() ) {
                /*
                 * When a Overlay is invoked by a modal Popup, the Popup itself
                 * will ignore mouse clicks anyway. We still absorb mouse
                 * clicks here in case a Overlay were to be used in some
                 * context other than a Popup.
                 */
                event.stopPropagation();
            }
        });
    },
    
    /*
     * Add the overlay to the DOM such that it ends up behind the target
     * element and in front of everything else (within that element's
     * stacking context).
     */
    lift: Control.iterator( function( $target ) {
        
        var targetCss = {
            position: $target.css( "position" ),
            "z-index": $target.css( "z-index" )
        };
        
        var targetPreviousCss = {};
        if ( targetCss.position === "static" ) {
            /*
             * Give the target relative positioning so its z-index will work.
             */
            targetPreviousCss.position = ( targetCss.position !== "static" )
                ? targetCss.position
                : "";
            $target.css( "position", "relative" );
        }
        
        var targetZIndex = parseInt( targetCss[ "z-index" ] ); 
        if ( isNaN( targetZIndex ) ) {
            /*
             * The target doesn't have a z-index, so we'll temporarily assign
             * a z-index of zero so it at least ends up above all other elements
             * with no z-index within the target's stacking context.
             */
            targetPreviousCss[ "z-index" ] = ( targetCss[ "z-index" ] !== "auto" )
                ? targetCss[ "z-index" ]
                : "";
            targetZIndex = 0;
            $target.css( "z-index", targetZIndex );
        }
        
        /*
         * The overlay ends up with the same z-index as the target, but at the
         * immediately before the target's location in the DOM, so the target
         * will appear over the overlay.
         */
        return this
            ._target( $target )
            ._targetPreviousCss( targetPreviousCss )
            .css( "z-index", targetZIndex )
            .insertBefore( $target );
    }),
    
    /*
     * True if the overlay absorbs clicks rather than letting them bubble up.
     */
    modal: Control.chain( "applyClass/modal" ),
    
    /*
     * Restore the target element to its original condition.
     * The overlay must be separately removed from the DOM (e.g., via a
     * call to jQuery's remove() function).
     */
    restore: Control.iterator( function() {
        var $target = this._target();
        if ( $target ) {
            // Undo any CSS we've applied
            var targetCss = this._targetPreviousCss();
            if ( targetCss.position != null ) {
                $target.css( "position", targetCss.position );
            }
            if ( targetCss[ "z-index" ] != null ) {
                $target.css( "z-index", targetCss[ "z-index" ] );
            }
            this
                ._target( null )
                ._targetPreviousCss( null );
        }
        return this;
    }),

    // The target element the overlay is being shown behind.    
    _target: Control.property(),
    
    // The saved values for any CSS properties on the target that we've touched. 
    _targetPreviousCss: Control.property()
    
});
</script>

</Control>
