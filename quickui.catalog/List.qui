<!--
Creates a set of controls, one for each item in a list.
-->

<Control className="List">

<script>
List.prototype.extend({
    
    // The control class that should be used to render items in the list.
    itemClass: Control.property[ "class" ]( function() { this._refresh(); }, Control ),
    
    // True if the control should mark itself dirty when it gets a change event.
    dirtyOnChange: Control.property.bool( null, false ),
    
    // True if the control contents have been changed since the controls were first created.
    isDirty: Control.property.bool( null, true ),
    
    // A copy of the items the last time they were created or refreshed.
    _itemsCache: Control.property(),
    
    initialize: function() {
        var self = this;
        this.change( function( event ) {
            if ( self.dirtyOnChange() ) {
                // Assume the list is dirty.
                self.isDirty( true );
            }
        });
    },
    
    /*
     * The collection of controls in the list generated by setting the items() property.
     * This is always returned as an instance of itemClass.
     */
    controls: function() {
        var itemClass = this.itemClass();
        return itemClass( this ).children();
    },
    
    // The items in the list.
    items: function( items ) {
        if ( items === undefined ) {
            if ( this.isDirty() ) {
                this
                    ._itemsCache( this._getItemsFromControls() )
                    .isDirty( false );
            }
            return this._itemsCache();
        } else {
            return this
                ._itemsCache( items )
                ._createControlsForItems( items )
                .isDirty( false );
        }
    },
    
    /*
     * Used to map an incoming list item to property setters on the control
     * class indicated by itemClass. This can be a simple string,
     * in which case it will be taken as the name of a control class property.
     * It can also be a dictionary mapping item properties to control class
     * properties. Finally, the map can also be a function of the form:
     *
     *      function foo( item ) { ... }
     *
     * where item is the list item.
     *
     * If item is undefined, the map function is being invoked as a getter,
     * and should extract the item from the control (available via "this").
     * If item is defined, the map function is being invoked as a setter, and
     * should pass the item to the control (e.g., by setting properties on it).
     */
    mapFunction: Control.property(
        function() { this._refresh(); },
        "content" // By default, items are passed to the content() property.
    ),
    
    /*
     * This can be extended by subclasses who want to perform per-control
     * set-up.
     */
    _setupControl: function( $control ) {},
    
    _createControlsForItems: function( items ) {
        var itemClass = this.itemClass();
        var mapFunction = this._getMapFunction();
        var self = this;
        var controls = $.map( items || [], function( item, index ) {
            var $control = itemClass.create();
            mapFunction.call( $control, item );
            self._setupControl( $control );
            return $control;
        });
        this.content( controls );
        return this;
    },
    
    _getItemsFromControls: function() {
        var mapFunction = this._getMapFunction();
        return this.controls().map( function( index, element ) {
            var $control = $( element ).control();
            return mapFunction.call( $control );
        }).get();
    },
    
    /*
     * If the list's mapFunction property is a simple string, create a
     * function that invokes the item control's property getter/setter with
     * that string name. Otherwise, return the mapFunction value as is.  
     */
    _getMapFunction: function() {
        var mapFunction = this.mapFunction();
        if ( typeof mapFunction === "string" ) {
            // Invoke the property with the given name.
            return function( item ) {
                return this[ mapFunction ]( item );
            }
        } else if ( $.isFunction( mapFunction) ) {
            // Use function as is.
            return mapFunction;
        } else {
            // Object dictionary mapping item members -> control properties.
            return function( item ) {
                if ( item === undefined ) {
                    // Getter
                    var result = {};
                    for ( key in mapFunction ) {
                        var propertyName = mapFunction[ key ];
                        var value = this[ propertyName ]();
                        result[ propertyName ] = value;
                    }
                    return result;
                } else {
                    // Setter
                    for ( key in mapFunction ) {
                        var propertyName = mapFunction[ key ];
                        var value = item[ key ];
                        this[ propertyName ]( value );
                    }
                }
            }
        }
    },

    // Get all the items, then recreate them again (possibly as different controls).        
    _refresh: function() {
        this.items( this.items() );
    }

});
</script>

</Control>
