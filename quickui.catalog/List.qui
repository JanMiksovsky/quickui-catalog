<!--
Creates a set of controls, one for each item in a list.
-->

<Control className="List">

<script>
List.prototype.extend({
    
    /*
     * collection of controls in the list generated by setting the items() property.
     * Read-only. This is always returned as an instance of itemClass.
     */
    controls: function() {
        var itemClass = this.itemClass();
        return itemClass( this ).children();
    },
    
    /*
     * True if the control should mark itself dirty when it gets a change event.
     * The default is false.
     */
    dirtyOnChange: Control.property.bool( null, false ),
    
    initialize: function() {
        var self = this;
        this.change( function( event ) {
            if ( self.dirtyOnChange() ) {
                // Assume the list is dirty.
                self.isDirty( true );
            }
        });
    },

    /*
     * Insert a new item before the existing item at the given index.
     */
    insertItemBefore: Control.iterator( function( item, index ) {

        // Create the control.
        var itemClass = this.itemClass();
        var $control = itemClass.create();
        var mapFunction = this._getMapFunction();
        mapFunction.call( $control, item );

        // Add the control to the list.
        var children = this.children();
        if ( children.length === 0 )
        {
            this.append( $control );
        } else {
            children.eq( index ).before( $control );
        }

        // Update the cached item array as well.
        var items = this._itemsCache() || [];
        items.splice( index, 0, item );
        this._itemsCache( items );
    }),
    
    /*
     * True if the list's items have been changed since the controls were first created.
     */
    isDirty: Control.property.bool( null, true ),

    /*
     * The class used to render items in the list as controls.
     */
    itemClass: Control.property[ "class" ]( function() {
        // Get the existing items.
        var items = this.isDirty() ? this.items() : this._itemsCache();
        this
            .empty()            // Throw out the existing controls.
            .items( items );    // Create new controls.
    }, Control ),
    
    /*
     * The array of items in the list.
     */
    items: function( items ) {
        if ( items === undefined ) {
            if ( this.isDirty() ) {
                this
                    ._itemsCache( this._getItemsFromControls() )
                    .isDirty( false );
            }
            return this._itemsCache();
        } else {
            // Cache a copy of the items array. We use a copy because the array
            // may later be manipulated withour knowledge.
            var itemsCopy = items.slice(0);
            return this
                ._itemsCache( itemsCopy )
                ._createControlsForItems( itemsCopy )
                .isDirty( false );
        }
    },
    
    /*
     * Used to map an incoming list item to property setters on the control
     * class indicated by itemClass. The map specifies a relationship between
     * control property getter/setter functions and the item. This map
     * can take several forms:
     *
     * 1. A simple string like "foo". This indicates that the item itself
     *    should be passed to the control property called foo().
     * 2. A JavaScript dictionary with entries of the form
     *        { controlProperty: itemProperty }
     *    For each entry, the indicated item.itemProperty will be passed to
     *    or from the corresponding control.controlProperty().
     * 3. A function of the form:
     *
     *      function foo( item ) { ... }
     *
     *    If item is undefined, the map function is being invoked as a getter,
     *    and should extract the item from the control (available via "this").
     *    If item is defined, the map function is being invoked as a setter, and
     *    should pass the item to the control (e.g., by setting properties on
     *    it).
     *
     * If no map function is identified, a default map function is used. This
     * function does the following:
     * * If the item is a plain JavaScript object with keys of the form
     *       { property: value }
     *   The indicate value will be passed to and from control.property()
     * * Otherwise, the item is passed to and from the control's content()
     *   property.
     */
    mapFunction: Control.property( function() {
        // TODO: Before storing new mapFunction, use old one to extract items
        // if the list is dirty. For now, if the mapFunction of a dirty list is
        // updated, the unsaved changes are thrown away.
        var items = this._itemsCache();
        this.items( items );    // Force refresh.
    }),

    /*
     * Remove the item at the indicated index.
     */
    removeItemAt: Control.iterator( function( index ) {
        var items = this._itemsCache();
        if ( index >= 0 && index < items.length ) {
            // Remove the control at that index.
            this.children().eq( index ).remove();
            // Remove our cached copy of the corresponding item.
            items.splice( index, 1 );
        }
    }),
    
    /*
     * Create a control for each item in the items array. Subclasses can override
     * this is they want to perform additional work when controls are being
     * created.
     */
    _createControlsForItems: function( items ) {
        var itemClass = this.itemClass();
        var mapFunction = this._getMapFunction();
        var $existingControls = this.controls();
        // Create (or reuse) a control for each item.
        var $control;
        for ( var i = 0, length = items.length; i < length; i++ ) {
            if ( i < $existingControls.length ) {
                $control = $existingControls.eq( i );
            } else {
                $control = itemClass.create();
                this.append( $control );
            }
            mapFunction.call( $control, items[i] );
            this._setupControl( $control );
        }
        var leftoverControls = $existingControls.slice( items.length );
        if ( leftoverControls.length > 0 ) {
            $( leftoverControls ).remove();
        }
        return this;
    },
    
    /*
     * Reconstruct the set of items from the controls.
     */
    _getItemsFromControls: function() {
        var mapFunction = this._getMapFunction();
        return this.controls().map( function( index, element ) {
            var $control = $( element ).control();
            return mapFunction.call( $control );
        }).get();
    },
    
    /*
     * Return a map function that can be applied to a control to get/set its
     * corresponding item. See mapFunction() for a description of the supported
     * means of identifying the map function.
     */
    _getMapFunction: function() {
        var mapFunction = this.mapFunction();
        if ( mapFunction === undefined ) {
            // No map function supplied; used the default.
            return List._defaultMapFunction;
        } else if ( typeof mapFunction === "string" ) {
            // The map function should invoke the property with the given name.
            return function( item ) {
                return this[ mapFunction ]( item );
            }
        } else if ( $.isFunction( mapFunction) ) {
            // An explicit map function has been supplied; use that.
            return mapFunction;
        } else {
            // An dictionary map has been supplied; return a function that
            // lets it map item members -> control properties and vice versa.
            return function( item ) {
                return List._applyDictionaryMap.call( this, mapFunction, item );
            }
        }
    },
    
    // A copy of the items the last time they were created or refreshed.
    _itemsCache: Control.property(),
    
    /*
     * This can be extended by subclasses who want to perform per-control
     * set-up.
     */
    _setupControl: function( $control ) {}

});

List.extend({
    
    /*
     * Apply a simple dictionary map to the given item. The map should contain
     * a mapping of { controlProperty: itemProperty } entries. When invoked as
     * a setter, this invokes
     *    control.controlProperty( item.itemProperty )
     * When invokes as a getter, this returns a new object with keys of the form
     *    { itemProperty: control.controlProperty() }
     *
     * Note: This function should be called with this = the given control.
     */
    _applyDictionaryMap: function( map, item ) {
        if ( item === undefined ) {
            // Getter
            var result = {};
            for ( key in map ) {
                var propertyName = map[ key ];
                var value = this[ propertyName ]();
                result[ propertyName ] = value;
            }
            return result;
        } else {
            // Setter
            for ( key in map ) {
                var propertyName = map[ key ];
                var value = item[ key ];
                this[ propertyName ]( value );
            }
        }
    },
    
    /*
     * This map function is used if the host does not provide one.
     */
    _defaultMapFunction: function( item ) {
        var map;
        if ( item === undefined ) {
            // Getter
            map = this.data( "_map" );
            if ( map ) {
                // Reconstruct an item using the previously-generated map.
                return List._applyDictionaryMap.call( this, map );
            } else {
                return this.content();
            }
        } else {
            // Setter
            if ( $.isPlainObject( item ) ) {
                // Generate a map from the item and save it for later use.
                map = {};
                for ( key in item ) {
                    if ( item.hasOwnProperty( key ) ) {
                        map[ key ] = key;
                    }
                }
                this.data( "_map", map );
                List._applyDictionaryMap.call( this, map, item );
            } else {
                // Map to content()
                return this.content( item );
            }
        }
    }

})
</script>

</Control>
