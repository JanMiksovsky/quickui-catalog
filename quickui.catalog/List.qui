<!--
Creates a set of controls, one for each item in a list.
-->

<Control name="List">

<script>
List.prototype.extend({
    
    // The control class that should be used to render items in the list.
    itemClass: Control.property[ "class" ]( function() { this._refresh(); }, Control ),
    
    // True if the control should mark itself dirty when it gets a change event.
    dirtyOnChange: Control.property.bool( null, false ),
    
    // True if the control contents have been changed since the controls were first created.
    isDirty: Control.property.bool( null, true ),
    
    // A copy of the items the last time they were created or refreshed.
    _itemsCache: Control.property(),
    
    initialize: function() {
        var self = this;
        this.change( function( event ) {
            if ( self.dirtyOnChange() ) {
                // Assume the list is dirty.
                self.isDirty( true );
            }
        });
    },
    
    /*
     * The collection of controls in the list generated by setting the items() property.
     * This is always returned as an instance of itemClass.
     */
    controls: function() {
        var itemClass = this.itemClass();
        return itemClass( this ).children();
    },
    
    // The items in the list.
    items: function( items ) {
        if ( items === undefined ) {
            if ( this.isDirty() ) {
                this
                    ._itemsCache( this._getItemsFromControls() )
                    .isDirty( false );
            }
            return this._itemsCache();
        } else {
            return this
                ._itemsCache( items )
                ._createControlsForItems( items )
                .isDirty( false );
        }
    },
    
    //
    // Used to map an incoming list item to property setters on the control
    // class indicated by itemClass. This can either be a simple string,
    // in which case it will be taken as the name of a control class property,
    // Alternately, this can be a function of the form:
    //
    //      function foo( item ) { ... }
    //
    // where item is the list item.
    //
    // If item is undefined, the map function is being invoked as a getter,
    // and should extract the item from the control (available via "this").
    // If item is defined, the map function is being invoked as a setter, and
    // should pass the item to the control (e.g., by setting properties on it).
    //
    mapFunction: Control.property(
        function() { this._refresh(); },
        "content"
    ),
    
    _createControlsForItems: function( items ) {
        var itemClass = this.itemClass();
        var mapFunction = this._getMapFunction();
        var controls = $.map( items || [], function( item, index ) {
            var $control = itemClass.create();
            mapFunction.call( $control, item );
            return $control;
        });
        this.content( controls );
        return this;
    },
    
    _getItemsFromControls: function() {
        var mapFunction = this._getMapFunction();
        return this.controls().map( function( index, element ) {
            var $control = $( element ).control();
            return mapFunction.call( $control );
        }).get();
    },
    
    /*
     * If the list's mapFunction property is a simple string, create a
     * function that invokes the item control's property getter/setter with
     * that string name. Otherwise, return the mapFunction value as is.  
     */
    _getMapFunction: function() {
        var mapFunction = this.mapFunction();
        return typeof mapFunction === "string"
            ? function( item ) { return this[ mapFunction ]( item ); }
            : mapFunction;
    },

    // Get all the items, then recreate them again (possibly as different controls).        
    _refresh: function() {
        this.items( this.items() );
    }

});
</script>

</Control>
