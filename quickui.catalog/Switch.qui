<!-- Pick exactly one child to show at a time. -->

<Control name="Switch">

<style>
.hidden {
    display: none !important;
}
</style>

<script>
Switch.prototype.extend({
    
    /*
     * The set of elements that will be held; only one will be shown at a time.
     * 
     * If the set changes, this will attempt to preserve the one that was
     * previously active. Otherwise, the first element is made active.
     */
    content: function( value ) {
        var previousChild = this.activeChild();
        var result = this._super( value );
        if ( value !== undefined ) {
            if ( previousChild && previousChild.parent()[0] === this[0] ) {
                // Still have previously active child; hide other children.
                this.activeChild( previousChild );
            } else {
                this.activeIndex( 0 );
            }
        }
        return result;
    },
    
    initialize: function() {
        if ( this.children().not( ".hidden" ).length > 1 ) {
            // Show first child by default. 
            this.activeIndex(0);
        }
    },
    
    /*
     * The currently visible child, cast to a control (if applicable).
     */
    activeChild: Control.iterator( function( activeChild ) {
        if ( activeChild === undefined ) {
            return this.children().not( ".hidden" ).eq(0).cast( jQuery );
        } else {
            
            /*
             * Apply a "hidden" style instead of just forcing display to none.
             * If we did that, we would have no good way to undo the hiding.
             * A simple .toggle(true) would set display: block, which wouldn't
             * be what we'd want for inline elements.
             */
            this.children().not( activeChild ).toggleClass( "hidden", true );

            var activeChildIndex = this.children().index( activeChild );

            // Tell the child it's now active, and show it.
            $( activeChild )
                .trigger( "active" )
                .toggleClass( "hidden", false );
            
            this
                // Trigger our own activeChildChanged event.
                .trigger( "activeChildChanged", [ activeChildIndex, activeChild ] )
            
                // In case the new child wants to re-lay itself out.
                .trigger( "sizeChanged" );
            
            return this;
        }
    }),
    
    // The index of the currently visible child.
    activeIndex: function( index ) {
        if ( index === undefined ) {
            return this.children().index( this.activeChild() );
        } else {
            return this.activeChild( this.children().eq( index ) );
        }
    }
        
});
</script>

</Control>
