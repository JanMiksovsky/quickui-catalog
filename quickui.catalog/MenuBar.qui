<!--
A standard menu bar.

Note: The menu bar places a Overlay instance underneath itself to absorb
clicks outside the menu. If you're using a MenuBar on a page with elements
that have an explicit z-index, you'll want to give the MenuBar a higher z-index
so that it (and its overlay) end up above all other elements when any menus
are open. See notes in the source for the Overlay class.
-->

<Control className="MenuBar" genericSupport="true">

<style>
{
    position: relative; /* Necessary to get overlay behind the whole menu bar */
    -moz-user-select: -moz-none;
    -webkit-user-select: none;
    user-select: none;
}

/* Subclasses can extend this style */
.MenuBar.opened {}

/* Generic appearance */
.MenuBar.generic {
    background: white;
    border-bottom: 1px solid #e5e5e5;
}
</style>

<script>
MenuBar.prototype.extend({
    
    /*
     * Close currently open any menus.
     */
    close: Control.iterator( function() {
        if ( !this.opened() ) {
            // Already closed
            return;
        }
        
        var $overlay = this._overlay();
        if ( $overlay ) {
            $overlay.remove();
            this._overlay( null );
        }
        
        this
            ._closeOpenPopups()
            .opened( false );
    }),
    
    /*
     * The menus in the menu bar. These are typically PopupSource controls,
     * including subclasses like Menu. Other types of controls can be
     * safely placed in the content as well.
     */
    content: function( content ) {
        var result = this._super( content );
        if ( content !== undefined ) {
            // Since we're managing our own overlay, we suppress the overlays
            // on the individual menus in our content.
            var popups = this.find( ".PopupSource" ).control();
            if ( popups ) {
                popups.overlayClass( null );
            }
        }
        return result;
    },
    
    initialize: function() {
        var self = this;
        this.on({
            "closed canceled": function( event ) {
                if ( self._openPopups() == null ) {
                    // No longer any open popups.
                    self.close();
                }
            },
            opened: function( event ) {
                self.open();
                // Close open popups other than the one which just opened.
                var newMenu = $( event.target ).closest( ".PopupSource" ).control();
                self._closeOpenPopups( newMenu );
            }
        });
        this.on( "mouseenter", ".PopupSource", function( event ) {
            if ( self.opened() ) {
                // Riffing: Implicitly open the popup the user hovered into
                // if it's not already open.
                var newMenu = $( event.target ).closest( ".PopupSource" ).control();
                if ( newMenu && !newMenu.opened() ) {
                    newMenu.open();
                }
            }
        });
    },
    
    /*
     * Returns true if any of the menu bar's menus are currently open.
     */
    opened: Control.chain( "applyClass/opened" ),
    
    open: Control.iterator( function() {
        
        if ( this.opened() ) {
            // Already open
            return;
        }
        
        var $overlay = Overlay.create().target( this );
        this._overlay( $overlay );
        
        this.opened( true );
    }),
    
    /*
     * Close open popups. If a keepPopup is specified, leave that menu open.
     */
    _closeOpenPopups: function( keepPopup ) {
        var openMenus = this._openPopups();
        if ( openMenus ) {
            openMenus = openMenus.not( keepPopup );
            if ( openMenus.length > 0 ) {
                openMenus.close();
            }
        }
        return this;
    },
    
    /*
     * Return the currently open popups.
     */
    _openPopups: Control.chain( "children", "filter/.PopupSource.opened", "control" ),

    // The overlay behind the menu bar.    
    _overlay: Control.property()
    
});
</script>

</Control>