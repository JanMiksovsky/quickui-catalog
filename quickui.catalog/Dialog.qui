<!--
Base class for modal dialogs.
-->

<Control className="Dialog">

<prototype>
    <Popup
        cancelOnOutsideClick="false"
        cancelOnWindowBlur="false"
        closeOnInsideClick="false"
        overlayClass="ModalOverlay"
    />
</prototype>

<style>
{
    position: fixed;
}

/* Generic appearance */
.Dialog.generic {
    background-color: white;
    border: 1px solid black;
    padding: .75em;
}
</style>

<script>
Dialog.prototype.extend({

    /*
     * Cancel the dialog. This implicitly closes the dialog.
     */    
    cancel: function() {
        return this
            ._super()
            .remove();
    },
    
    /*
     * Close the dialog normally.
     */
    close: function() {
        return this
            ._super()
            .remove();
    },
    
    initialize: function() {
        this._super();
        this.genericIfClassIs( Dialog );
        var self = this;
        this.positionPopup( function() {
            self._positionPopup();
        });
    },
    
    /*
     * Position the dialog.
     * By default, center dialog horizontally and vertically. 
     */
    _positionPopup: function() {
        return this.css({
            left: ( $( window ).width() - this.outerWidth() ) / 2,
            top: ( $( window ).height() - this.outerHeight() ) / 2
        });
    }

});

// Class methods
Dialog.extend({
    
    /*
     * Create and show an instance of a given dialog class.
     */
    showDialog: function( dialogClass, properties, callbackOk, callbackCancel ) {
        
        var dialog = dialogClass.create( properties )
            .on({
                closed: function() {
                    if ( callbackOk ) {
                        callbackOk.call( $( this ).control() );
                    }
                },
                canceled: function() {
                    if ( callbackCancel ) {
                        callbackCancel.call( $( this ).control() );
                    }
                }
            });
        
        var maximumZIndex = Dialog._maximumZIndex();
        if ( maximumZIndex ) {
            /*
             * Use a z-index one higher than the highest one in use on the page.
             * 
             * Technically speaking, we might be able to get away with using a
             * lower z-index if we very carefully looked at the actual stacking
             * contexts, but that would be a bunch more work, and all we care
             * about here is making sure a transient element ends up above
             * everything else.    
             */
            dialog.css( "z-index", maximumZIndex + 1 );
        }
        
        /*
         * Add the dialog to the end of the body so that it will paint over
         * other controls in the same stacking context.
         */
        $( document.body).append( dialog );
        
        dialog.open();
    },
    
    /*
     * Return the maximum Z-index in use on the page, or null if none is set.
     */
    _maximumZIndex: function()
    {
        var zIndices = $( "*" ).map( function( index, element ) {
            var $element = $( element );
            // z-index only applies if position is also set.
            if ( $element.css("position") !== "static" ) {
                var zIndex = parseInt( $element.css( "z-index" ) );
                if ( zIndex ) {
                    return zIndex;
                }
            }
        }).get();
        
        return ( zIndices.length > 0 )
            ? Math.max.apply( null, zIndices )
            : null;
    }
    
});
</script>

</Control>
