<!--
Base class for popups, menus, dialogs, things that appear temporarily over other things.
-->

<Control className="Popup">

<style>
{
    display: none;
    position: absolute;
    z-index: 0;
}

.Popup.opened {
    display: block;
}

/* Generic appearance */
.Popup.generic {
    background: white;
    border: 1px solid #ccc; /* IE8 */
    border: 1px solid rgba(0, 0, 0, 0.2);
    -webkit-box-shadow: 0 2px 4px rgba( 0, 0, 0, 0.2 );
    -moz-box-shadow: 0 2px 4px rgba( 0, 0, 0, 0.2 );
    box-shadow: 0 2px 4px rgba( 0, 0, 0, 0.2 );
    -moz-box-sizing: border-box;
    -ms-box-sizing: border-box;
    -webkit-box-sizing: border-box;
    box-sizing: border-box;
    padding: .25em;
    -moz-user-select: -moz-none;
    -webkit-user-select: none;
    user-select: none;
}
</style>

<script>
Popup.prototype.extend({
    
    /*
     * True if the user can cancel an open popup by pressing the Escape key.
     * Default is true.
     */
    cancelOnEscapeKey: Control.property.bool( null, true ),
    
    /*
     * True if the popup should be canceled if the user clicks outside it.
     * Default is true. See also the modal() property.
     */
    cancelOnOutsideClick: Control.property.bool( null, true ),
    
    /*
     * True if the popup should be canceled if the window loses focus.
     * Default is true.
     */
    cancelOnWindowBlur: Control.property.bool( null, true ),
    
    /*
     * True if the popup should be canceled if the window changes size.
     * Default is true.
     */
    cancelOnWindowResize: Control.property.bool( null, true ),
    
    /*
     * True if the popup should be closed normally if the user clicks inside
     * it. Default is true.
     */
    closeOnInsideClick: Control.property.bool( null, true ),
    
    /*
     * Cancel the popup. This is just like closing it, but raises a "canceled"
     * event instead.
     * 
     * This has no effect if the popup is already closed.
     */
    cancel: function() {
        return this._close( "canceled" );
    },
    
    /*
     * Close the popup (dismiss it). This raises a "closed" event.
     * 
     * This has no effect if the popup is already closed.
     */
    close: function() {
        return this._close( "closed" );
    },
    
    initialize: function()
    {
        this.genericIfClassIs( Popup );
        if ( this.overlayClass() === undefined ) {
            this.overlayClass( Overlay );
        }
    },

    /*
     * Open the popup (show it). This raises an "opened" event.
     * 
     * This has no effect if the popup is already opened.
     */
    open: function()
    {
        if ( this.opened() ) {
            // Already opened
            return this;
        }

        var overlayClass = this.overlayClass();
        if ( overlayClass ) {
            var $overlay = overlayClass.create().target( this );
            this._overlay( $overlay );
        }
        
        return this
            ._eventsOn()
            .opened( true )
            .trigger( "opened" )
            // In case popup wants to resize anything now that it's visible.
            .checkForSizeChange()
            // Position the popup after the layout recalc.
            .positionPopup();
    },
    
    /*
     * Open the popup.
     */
    opened: Control.chain( "applyClass/opened" ),
    
    /*
     * The class used to render the overlay behind the popup. The default
     * value is the Overlay class.
     */
    overlayClass: Control.property[ "class" ](),
    
    /*
     * A function called to position the popup when it is opened. By default
     * this has no effect. This can be overridden by subclasses for custom
     * positioning.
     */
    positionPopup: function() {},

    /*
     * Take care of hiding the popup, its overlay, and raising the indicated event.
     */
    _close: function( closeEventName )
    {
        // There may be cases where this function is called more than once.
        // As a defensive measure, we clean things up even if we think we're
        // already closed.
        if ( this._overlay() != null ) {
            this._overlay().remove();
            this._overlay( null );
        }
        this._eventsOff();

        if ( this.opened() ) {
            if ( closeEventName ) {
                this.trigger( closeEventName );
            }
            this.opened( false );
        }
        
        return this;
    },
    
    /*
     * Wire up events.
     */
    _eventsOn: function() {
        
        // Create the handlers as functions we can save in control properties.
        var self = this;
        var handlerDocumentKeydown = function( event ) {
            if ( self.cancelOnEscapeKey() && event.which === 27 /* Escape */ ) {
                // Pressing ESC cancels popup.
                self.cancel();
                event.stopPropagation();
            }
        };
        var handlerDocumentClick = function( event ) {
            var outsideClick = ( $( event.target ).parents().filter( self ).length === 0 );
            if ( outsideClick && self.cancelOnOutsideClick() ) {
                // User clicked outside popup; implicitly cancel it.
                self.cancel();
            } else if ( !outsideClick && self.closeOnInsideClick() ) {
                // Use click inside popup; implicitly close it.
                self.close();
            }
        };
        var handlerWindowBlur = function( event ) {
            if ( self.cancelOnWindowBlur() ) {
                // Cancel popup when window loses focus.
                self.cancel();
            }
        };
        var handlerWindowResize = function( event ) {
            if ( self.cancelOnWindowResize() ) {
                // Cancel popup when window changes size.
                self.cancel();
            }
        };

        $( document ).on( "keydown", handlerDocumentKeydown );
        $( window ).on({
            blur: handlerWindowBlur,
            resize: handlerWindowResize,
        });
        
        /*
         * Wire up document click handler in a timeout. We do this because a
         * popup is often invoked in response to a click. That triggering
         * click hasn't reached the document yet. If we bound the document click
         * event right now, the triggering click would soon reach the document,
         * immediately triggering cancelation of the popup. The use of a timeout
         * gives the triggering click a chance to bubble all the way up to the
         * document before we wire up the document click handler.
         */
        window.setTimeout( function() {
            // Don't bind event if we managed to get closed during the timeout.
            if ( self.opened() ) {
                $( document ).on( "click", handlerDocumentClick );
            }
        }, 100 );
        
        // Save references to the event handlers so we can unbind them later.
        return this
            ._handlerDocumentClick( handlerDocumentClick )
            ._handlerDocumentKeydown( handlerDocumentKeydown )
            ._handlerWindowBlur( handlerWindowBlur )
            ._handlerWindowResize( handlerWindowResize );
    },
    
    /*
     * Unbind the event handlers we bound earlier.
     */
    _eventsOff: function() {
        
        // Do checks before unbinding in case this function happens to get
        // called more than once.
         
        var handlerDocumentClick = this._handlerDocumentClick();
        if ( handlerDocumentClick ) {
            $( document ).off( "click", handlerDocumentClick );
            this._handlerDocumentClick( null );
        }
        
        var handlerDocumentKeydown = this._handlerDocumentKeydown();
        if ( handlerDocumentKeydown ) {
            $( document ).off( "keydown", handlerDocumentKeydown );
            this._handlerDocumentKeydown( null );
        }
        
        var handlerWindowBlur = this._handlerWindowBlur();
        if ( handlerWindowBlur ) {
            $( window ).off( "blur", handlerWindowBlur );
            this._handlerWindowBlur( null );
        }
        
        var handlerWindowResize = this._handlerWindowResize();
        if ( handlerWindowResize ) {
            $( window ).off( "resize", handlerWindowResize );
            this._handlerWindowResize( null );
        }
        
        return this;
    },
    
    // Handler for the document click event
    _handlerDocumentClick: Control.property(),

    // Handler for the keydown event
    _handlerDocumentKeydown: Control.property(),
    
    // Handler for the window blur event
    _handlerWindowBlur: Control.property(),
    
    // Handler for the window resize event
    _handlerWindowResize: Control.property(),

    // The Overlay control behind the popup absorbing mouse clicks.
    _overlay: Control.property()

});
</script>

</Control>