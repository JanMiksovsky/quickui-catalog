<!--
Base class for popups, menus, dialogs, things that appear temporarily over other things.
-->

<Control className="Popup">

<style>
{
    display: none;
    position: absolute;
    z-index: 1;
}

.Popup.opened {
    display: block;
}

/* Generic appearance */
.Popup.generic {
    background: white;
    border: 1px solid gray;
    box-shadow: 3px 3px 5px rgba( 0, 0, 0, 0.5 );
    -moz-box-sizing: border-box;
    -ms-box-sizing: border-box;
    -webkit-box-sizing: border-box;
    box-sizing: border-box;
    padding: .25em;
    -moz-user-select: -moz-none;
    -webkit-user-select: none;
    user-select: none;
}
</style>

<script>
Popup.prototype.extend({

    blanket: Control.property(),
    blanketColor: Control.property(),
    blanketOpacity: Control.property(),
    
    /*
     * True if the user can cancel an open popup by pressing the Escape key.
     * Default is true.
     */
    cancelOnEscapeKey: Control.property.bool( null, true ),
    
    /*
     * True if the popup should be cancelled if the user clicks outside it.
     * Default is true.
     */
    cancelOnOutsideClick: Control.property.bool( null, true ),
    
    /*
     * True if the popup should be cancelled if the window loses focus.
     * Default is true.
     */
    cancelOnWindowBlur: Control.property.bool( null, true ),
    
    /*
     * True if the popup should be closed normally if the user clicks inside
     * it. Default is true.
     */
    closeOnInsideClick: Control.property.bool( null, true ),
    
    initialize: function()
    {
        var self = this;
        this
            .click( function() {
                if ( self.closeOnInsideClick() )
                {
                    self.close();
                }
            })
            .genericIfClassIs( Popup );

        // When window loses focus, cancel the popup. This is wired up later.
        this._windowBlurHandler( function() {
            if ( self.cancelOnWindowBlur() ) {
                self.cancel();
            }
        });
    },
    
    /*
     * Cancel the popup. This is just like closing it, but raises a "canceled"
     * event instead.
     * 
     * This has no effect if the popup is already closed.
     */
    cancel: function() {
        return this._close( "canceled" );
    },
    
    /*
     * Close the popup (dismiss it). This raises a "closed" event.
     * 
     * This has no effect if the popup is already closed.
     */
    close: function() {
        return this._close( "closed" );
    },

    /*
     * Open the popup (show it). This raises an "opened" event.
     * 
     * This has no effect if the popup is already opened.
     */
    open: function()
    {
        if ( this.opened() ) {
            return this;
        }

        var $blanket = Blanket.create().lift( this )
        this.blanket( $blanket );
        
        this
            ._bindKeydownHandler( true )
            .opened( true )
            .trigger( "opened" )
            // In case popup wants to resize anything now that it's visible.
            .checkForSizeChange();
        
        // Position the popup after the layout recalc.
        var positionPopup = this.positionPopup();
        if ( positionPopup ) {
            positionPopup.call( this );
        }
        
        // Listen for window blur event.
        $( window ).on( "blur", this._windowBlurHandler() );
        
        return this;
    },
    
    /*
     * Open the popup.
     */
    opened: Control.chain( "applyClass/opened" ),
    
    /*
     * A callback function that will be invoked to position the popup.
     * This is implemented as a property instead of an overrideable method
     * so that the position logic can be set on a per-instance basis without
     * having to create a new subclass.
     */
    positionPopup: Control.property(),
    
    _bindKeydownHandler: function( handleKeydown ) {
        var handler;
        if ( handleKeydown ) {
            var self = this;
            handler = function( event) {
                if ( self.cancelOnEscapeKey() && event.keyCode === 27 /* Escape */ ) {
                    self.cancel();
                }
            }
            this.data( "_keydownHandler", handler );
            $( document ).on( "keydown", handler );
        } else {
            handler = this.data( "_keydownHandler" );
            if ( handler ) {
                $( document ).unbind( "keydown", handler );
            }
        }
        return this;
    },

    /*
     * Take care of hiding the popup, its blanket, and raising the indicated event.
     */
    _close: function( closeEventName )
    {
        if ( !this.opened() ) {
            // Already closed
            return this;
        }
        
        if ( closeEventName ) {
            this.trigger( closeEventName );
        }

        this
            ._bindKeydownHandler( false )
            .opened( false );
            
        if ( this.blanket() != null ) {
            this.blanket().restore();
            this.blanket().remove();
            this.blanket(null);
        }
        
        // Stop listening for window blur.
        // Listen for window blur event.
        $( window ).unbind( "blur", this._windowBlurHandler() );
        
        return this;
    },

    _createBlanket: function() {
        
        var $blanket = this
            .after( "<div id='blanket'/>" )
            .next();
            
        var cancelOnOutsideClick = this.cancelOnOutsideClick();
        var color = this.blanketColor() ||
                        ( cancelOnOutsideClick ? false : "black" );
        var opacity = this.blanketOpacity() ||
                        ( cancelOnOutsideClick ? 0.01 : 0.25 );
            
        var self = this;
        $blanket
            .click( function() {
                if ( self.cancelOnOutsideClick() ) {
                    self.cancel();
                }
            })
            .css({
                cursor: "default",
                position: "fixed",
                opacity: opacity,
                top: 0,
                left: 0,
                width: "100%",
                height: "100%"
            });
        if ( color ) {
            $blanket.css( "background-color", color );
        }
        
        return $blanket;
    },
    
    _windowBlurHandler: Control.property(),

});
</script>

</Control>