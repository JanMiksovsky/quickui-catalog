<!--
Base class for popups, menus, dialogs, things that appear temporarily over other things.
-->

<Control className="Popup">

<style>
{
    display: none;
    position: absolute;
    z-index: 0;
}

.Popup.opened {
    display: block;
}

/* Generic appearance */
.Popup.generic {
    background: white;
    border: 1px solid gray;
    box-shadow: 3px 3px 5px rgba( 0, 0, 0, 0.5 );
    -moz-box-sizing: border-box;
    -ms-box-sizing: border-box;
    -webkit-box-sizing: border-box;
    box-sizing: border-box;
    padding: .25em;
    -moz-user-select: -moz-none;
    -webkit-user-select: none;
    user-select: none;
}
</style>

<script>
Popup.prototype.extend({
    
    /*
     * True if the user can cancel an open popup by pressing the Escape key.
     * Default is true.
     */
    cancelOnEscapeKey: Control.property.bool( null, true ),
    
    /*
     * True if the popup should be canceled if the user clicks outside it.
     * Default is true. See also the modal() property.
     */
    cancelOnOutsideClick: Control.property.bool( null, true ),
    
    /*
     * True if the popup should be canceled if the window loses focus.
     * Default is true.
     */
    cancelOnWindowBlur: Control.property.bool( null, true ),
    
    /*
     * True if the popup should be closed normally if the user clicks inside
     * it. Default is true.
     */
    closeOnInsideClick: Control.property.bool( null, true ),
    
    /*
     * Cancel the popup. This is just like closing it, but raises a "canceled"
     * event instead.
     * 
     * This has no effect if the popup is already closed.
     */
    cancel: function() {
        return this._close( "canceled" );
    },
    
    /*
     * Close the popup (dismiss it). This raises a "closed" event.
     * 
     * This has no effect if the popup is already closed.
     */
    close: function() {
        return this._close( "closed" );
    },
    
    initialize: function()
    {
        this.genericIfClassIs( Popup );
        if ( this.overlayClass() === undefined ) {
            this.overlayClass( Overlay );
        }
    },

    /*
     * Open the popup (show it). This raises an "opened" event.
     * 
     * This has no effect if the popup is already opened.
     */
    open: function()
    {
        if ( this.opened() ) {
            // Already opened
            return this;
        }

        var overlayClass = this.overlayClass();
        if ( overlayClass ) {
            var $overlay = overlayClass.create()
                .lift( this.target() || this );
            this._overlay( $overlay );
        }
        
        this
            ._eventsOn()
            .opened( true )
            .trigger( "opened" )
            // In case popup wants to resize anything now that it's visible.
            .checkForSizeChange();
        
        // Position the popup after the layout recalc.
        var positionPopup = this.positionPopup();
        if ( positionPopup ) {
            positionPopup.call( this );
        }
        
        return this;
    },
    
    /*
     * Open the popup.
     */
    opened: Control.chain( "applyClass/opened" ),
    
    /*
     * The class used to render the overlay behind the popup. The default
     * value is the Overlay class.
     */
    overlayClass: Control.property[ "class" ](),
    
    /*
     * A callback function that will be invoked to position the popup.
     * This is implemented as a property instead of an overrideable method
     * so that the position logic can be set on a per-instance basis without
     * having to create a new subclass.
     */
    positionPopup: Control.property(),
    
    target: Control.property(),

    /*
     * Take care of hiding the popup, its overlay, and raising the indicated event.
     */
    _close: function( closeEventName )
    {
        if ( !this.opened() ) {
            // Already closed
            return this;
        }
        
        if ( closeEventName ) {
            this.trigger( closeEventName );
        }

        if ( this._overlay() != null ) {
            // Destroy overlay
            this._overlay()
                .restore()
                .remove();
            this._overlay(null);
        }
        
        return this
            ._eventsOff()
            .opened( false );
    },
    
    /*
     * Wire up events.
     */
    _eventsOn: function() {
        
        // Create the handlers as functions we can save in control properties.
        var self = this;
        var handlerDocumentKeydown = function( event ) {
            if ( self.cancelOnEscapeKey() && event.which === 27 /* Escape */ ) {
                // Pressing ESC cancels popup.
                self.cancel();
                event.stopPropagation();
            }
        };
        var handlerDocumentClick = function( event ) {
            var outsideClick = ( $( event.target ).parents().filter( self ).length === 0 );
            if ( outsideClick && self.cancelOnOutsideClick() ) {
                // User clicked outside popup; implicitly cancel it.
                self.cancel();
            } else if ( !outsideClick && self.closeOnInsideClick() ) {
                // Use click inside popup; implicitly close it.
                self.close();
            }
        };
        var handlerWindowBlur = function( event ) {
            if ( self.cancelOnWindowBlur() ) {
                // Cancel popup when window loses focus.
                self.cancel();
            }
        };

        $( document ).on( "keydown", handlerDocumentKeydown );
        $( window ).on( "blur", handlerWindowBlur );
        /*
         * Wire up document click handler in a timeout. We do this because a
         * popup is often invoked in response to a click. That triggering
         * click hasn't reached the document yet. If we bound the document click
         * event right now, the triggering click would soon reach the document,
         * immediately triggering cancelation of the popup. The use of a timeout
         * gives the triggering click a chance to bubble all the way up to the
         * document before we wire up the document click handler.
         */
        window.setTimeout( function() {
            // Don't bind event if we managed to get closed during the timeout.
            if ( self.opened() ) {
                $( document ).on( "click", handlerDocumentClick );
            }
        }, 100 );
        
        // Save references to the event handlers so we can unbind them later.
        return this
            ._handlerDocumentClick( handlerDocumentClick )
            ._handlerDocumentKeydown( handlerDocumentKeydown )
            ._handlerWindowBlur( handlerWindowBlur );
    },
    
    /*
     * Unbind the event handlers we bound earlier.
     */
    _eventsOff: function() {
        $( document ).off({
            click: this._handlerDocumentClick(),
            keydown: this._handlerDocumentKeydown()
        });
        $( window ).off( "blur", this._handlerWindowBlur() );
        return this
            ._handlerDocumentClick( null )
            ._handlerDocumentKeydown( null )
            ._handlerWindowBlur( null )
    },
    
    // Handler for the document click event
    _handlerDocumentClick: Control.property(),

    // Handler for the keydown event
    _handlerDocumentKeydown: Control.property(),
    
    // Handler for the window blur event
    _handlerWindowBlur: Control.property(),

    // The Overlay control behind the popup absorbing mouse clicks.
    _overlay: Control.property()

});
</script>

</Control>