<!--
Base class for popups, menus, dialogs, things that appear temporarily over other things.
-->

<Control className="Popup">

<style>
{
    display: none;
    position: absolute;
    z-index: 1;
}

/* Generic appearance */
.Popup.generic {
    background: white;
    border: 1px solid gray;
    box-shadow: 3px 3px 5px rgba( 0, 0, 0, 0.5 );
    -moz-box-sizing: border-box;
    -ms-box-sizing: border-box;
    -webkit-box-sizing: border-box;
    box-sizing: border-box;
    padding: .25em;
    -moz-user-select: -moz-none;
    -webkit-user-select: none;
    user-select: none;
}
</style>

<script>
Popup.prototype.extend({

    blanket: Control.property(),
    blanketColor: Control.property(),
    blanketOpacity: Control.property(),
    cancelOnEscapeKey: Control.property.bool( null, true ),
    cancelOnOutsideClick: Control.property.bool( null, true ),
    closeOnInsideClick: Control.property.bool(),
    _windowBlurHandler: Control.property(),
    
    initialize: function()
    {
        var self = this;
        this
            .click( function() {
                if ( self.closeOnInsideClick() )
                {
                    self.close();
                }
            })
            .genericIfClassIs( Popup );

        // When window loses focus, cancel the popup. This is wired up later.
        this._windowBlurHandler( function() {
            self.cancel();
        });
    },
    
    /*
     * Cancel the popup. This is just like closing it, but raises a "canceled"
     * event instead.
     * 
     * This has no effect if the popup is already closed.
     */
    cancel: function() {
        return !this.opened()
            ? this
            : this
                .trigger( "canceled" )
                ._hidePopup();
    },
    
    /*
     * Close the popup (dismiss it).
     * 
     * This has no effect if the popup is already closed.
     */
    close: function() {
        return !this.opened()
            ? this
            : this
                .trigger("closed")
                ._hidePopup();
    },

    /*
     * Open the popup (show it).
     * 
     * This has no effect if the popup is already opened.
     */
    open: function()
    {
        if ( this.opened() ) {
            return this;
        }
        
        if ( this.blanket() == null ) {
            this.blanket( this._createBlanket() );
        }
        
        /* Show control and blanket at the top of the Z-order. */
        var maximumZIndex = this._maximumZIndex();
        this.blanket()
            .css( "z-index", maximumZIndex + 1 )
            .show();
            
        this
            ._bindKeydownHandler( true )
            .css( "z-index", maximumZIndex + 2 )
            .show()
            .trigger( "opened" );
            
        // In case the overlay wants to resize anything now that it's visible.
        Layout.recalc();
        
        // Position the popup after the layout recalc.
        var positionPopup = this.positionPopup();
        if ( positionPopup ) {
            positionPopup.call( this );
        }
        
        // Listen for window blur event.
        $( window ).bind( "blur", this._windowBlurHandler() );
        
        return this;
    },
    
    // Return true if the popup is currently open (visible).
    opened: function() {
        return this.blanket() != null;
    },
    
    /*
     * A callback function that will be invoked to position the popup.
     * This is implemented as a property instead of an overrideable method
     * so that the position logic can be set on a per-instance basis without
     * having to create a new subclass.
     */
    positionPopup: Control.property(),
    
    _bindKeydownHandler: function( handleKeydown ) {
        var handler;
        if ( handleKeydown ) {
            var self = this;
            handler = function( event) {
                if ( self.cancelOnEscapeKey() && event.keyCode === 27 /* Escape */ ) {
                    self.cancel();
                }
            }
            this.data( "_keydownHandler", handler );
            $( document ).bind( "keydown", handler );
        } else {
            handler = this.data( "_keydownHandler" );
            if ( handler ) {
                $( document ).unbind( "keydown", handler );
            }
        }
        return this;
    },

    _createBlanket: function() {
        
        var $blanket = this
            .after( "<div id='blanket'/>" )
            .next();
            
        var cancelOnOutsideClick = this.cancelOnOutsideClick();
        var color = this.blanketColor() ||
                        ( cancelOnOutsideClick ? false : "black" );
        var opacity = this.blanketOpacity() ||
                        ( cancelOnOutsideClick ? 0.01 : 0.25 );
            
        var self = this;
        $blanket
            .click( function() {
                if ( self.cancelOnOutsideClick() ) {
                    self.cancel();
                }
            })
            .css({
                cursor: "default",
                position: "fixed",
                opacity: opacity,
                top: 0,
                left: 0,
                width: "100%",
                height: "100%"
            });
        if ( color ) {
            $blanket.css( "background-color", color );
        }
        
        return $blanket;
    },

    _hidePopup: function()
    {
        this
            ._bindKeydownHandler( false )
            .hide()
            .css( "z-index", null ); // No need to define Z-order any longer.
        if ( this.blanket() != null ) {
            this.blanket().remove();
            this.blanket(null);
        }
        
        // Stop listening for window blur.
        // Listen for window blur event.
        $( window ).unbind( "blur", this._windowBlurHandler() );
        
        return this;
    },

    /* Return the maximum Z-index in use by the page and its top-level controls. */
    _maximumZIndex: function()
    {
        var topLevelElements = $( "body" ).children().andSelf();
        var zIndices = $.map( topLevelElements, function( element ) {
            switch ( $(element).css("position") ) {
                case "absolute":
                case "fixed":
                    var zIndex = parseInt( $( element ).css( "z-index" ) ) || 1;
                    return zIndex;
            }
        });
        return Math.max.apply( null, zIndices );
    }
});
</script>

</Control>