<!--
A text box that makes itself big enough to show its content.
This works by copying the text to a hidden div which will automatically grow in size;
the expanding copy will expand the container, which in turn stretch the text box.
-->

<Control className="AutoSizeTextBox">

<content>
    
    <!-- Visible text box -->
    <textarea id="textBox"/>
    
    <!-- Hidden copy of text. Use a pre tag to preserve line breaks, entities, etc. -->
    <pre id="textCopy"/>
    
</content>

<style>
{
    position: relative;
}

#textBox {
    -moz-box-sizing: border-box;
    -ms-box-sizing: border-box;
    -webkit-box-sizing: border-box;
    box-sizing: border-box;
    height: 100%;
    margin: 0;
    overflow: hidden;
    position: absolute;
    resize: none;
    top: 0;
    width: 100%;
}

#textCopy {
    box-sizing: border-box;
    -moz-box-sizing: border-box;
    -ms-box-sizing: border-box;
    -webkit-box-sizing: border-box;
    margin: 0;
    visibility: hidden;
    white-space: pre-wrap; /* So lines wrap */
    width: 100%;
}
</style>

<script>
AutoSizeTextBox.prototype.extend({
    
    initialize: function() {
        
        var self = this;
        this.$textBox().bind({
            "change keyup": function( event ) {
                self.autoSize();
            },
            keypress: function( event ) {
                if ( event.which === 13 /* Enter */ ) {
                    // Speculatively add a line to our copy of the text.
                    /*
                     * We're not sure what the exact effect of typing this
                     * character will be, and at this point it's not reflected
                     * yet in the text box's content. We speculate that it
                     * will add a line to the text and size accordingly.
                     * (One other possibility is that the user's replacing
                     * a selected chunk of text with a newline.) In any event,
                     * once we get the keyup or change event, we'll make any
                     * final adjustments.
                     */
                    self.autoSize( true );
                }
            }
        });
        
        this.inDocument( function( $control  ) {
            $control._refresh();
        });
    },

    /*
     * Resize the text box to exactly contain its content.
     * 
     * We do this by copying the text box contents to the hidden copy.
     * That copy will size appropriately, which will make the overall control
     * the right height, which will then size the text box.
     */
    autoSize: Control.iterator( function( addExtraLine ) {
        
        var content = this.$textBox().content();
        
        if ( addExtraLine ) {
            content += "\n";
        }
        
        // See if last line of content ends in a newline (extra or otherwise).
        if ( content.slice( -1 ) === "\n" ) {
            // Add an extra space so that the last line will get fully rendered.
            content += " "; 
        }
        
        this.$textCopy().text( content );
    }),
    
    content: Control.chain( "$textBox", "content", function() {
        this.autoSize();
    }),
    
    /*
     * The minimum number of lines that should be shown.
     * The default value of 2 creates a textarea at least two lines
     * tall, which helps the user intuit the ability to type multiple
     * lines of text.
     */
    minimumLines: Control.property.integer( function( minimumLines ) {
        if ( this.inDocument() ) {
            this._refresh();
        }
    }, 2 ),
    
    /*
     * Set to false to disable spell-checking.
     */
    spellcheck: Control.chain( "$textBox", "prop/spellcheck" ),
    
    // For the following, we need to wait until the control's in the DOM.    
    _refresh: Control.iterator( function() {

        var $textBox = this.$textBox();
        var $textCopy = this.$textCopy();
        
        // Copy the control's font to the textarea and text copy.
        // This ensures both end up with the same text metrics.
        this.children().css({
            "font-family": this.css( "font-family" ),
            "font-size": this.css( "font-size" ),
            "font-style": this.css( "font-style" ),
            "font-weight": this.css( "font-weight" )
        });

        // Try to get the text box's line height. Unfortunately some browsers
        // return the useful value "normal", in which case we have to make
        // an estimate based on font size.
        var lineHeight = parseInt( $textBox.css( "line-height" ) );
        if ( isNaN( lineHeight ) ) {
            // line-height values like "normal" don't give us a measurement
            // we can use. We fall back to estimating a line height
            // based on font size. We then apply this to both the text box
            // and the copy so they both have the same font-size.
            lineHeight = Math.floor( parseInt( $textBox.css( "font-size" ) ) * 1.25 );
            $textBox.css( "line-height", lineHeight + "px" );
        } 
        $textCopy.css( "line-height", lineHeight + "px" );
        
        // Mirror the textarea's padding and borders on the text copy.
        // NOTE: Firefox seems to report 0px padding for the text box, even when there
        // appears to be 1px padding on a standard textarea. WebKit gets this right.
        // Perhaps there's some way in Firefox to detect and correct the error, but
        // for the time being this seems to work okay.
        var borderBottomWidth = $textBox.css( "border-bottom-width" );
        var borderLeftWidth = $textBox.css( "border-left-width" );
        var borderRigthWidth = $textBox.css( "border-right-width" );
        var borderTopWidth = $textBox.css( "border-top-width" );
        var paddingBottom = $textBox.css( "padding-bottom" );
        var paddingLeft = $textBox.css( "padding-left" );
        var paddingRight = $textBox.css( "padding-right" );
        var paddingTop = $textBox.css( "padding-top" );
        $textCopy.css({
            "border-bottom-width": borderBottomWidth,
            "border-left-width": borderLeftWidth,
            "border-right-width": borderRigthWidth,
            "border-top-width": borderTopWidth,  
            "padding-bottom": paddingBottom,  
            "padding-left": paddingLeft,
            "padding-right": paddingRight,
            "padding-top": paddingTop
        });

        var minimumLines = this.minimumLines();
        if ( minimumLines ) {
            
            // Convert the number of lines into a minimum height.
            var height = minimumLines * lineHeight;
            
            // Mozilla incorrectly includes padding+border in height when
            // -moz-box-sizing is border-box. The other browsers do not,
            // so for those browsers we need to add it in.
            if ( !$.browser.mozilla ) {
                height += parseInt( borderTopWidth )
                        + parseInt( paddingTop )
                        + parseInt( paddingBottom )
                        + parseInt( borderBottomWidth );
            }
            
            this.$textCopy().css( "min-height", height + "px" );
        }
    })
    
});
</script>

</Control>
