<!--
Renders a list of items in a combo box.

The user can type arbitrary text; if they type the beginning of a list item's
content, the remainder of the item's content is AutoCompleted. For this to
work, both the control's content and the content of the list items should
be strings.
-->

<Control className="ListComboBox">

<prototype>
    <ComboBox>
        <popup>
            <ListBox id="list"/>
        </popup>
    </ComboBox>
</prototype>

<style>
#list {
    border: none;
    -moz-outline: none;
    outline: none;
}
#list > * {
    display: block;
}

/* Generic appearance */
.ListComboBox.generic .BasicButton {
    border: none;
}
</style>

<script>
ListComboBox.prototype.extend({
    
    
    /*
     * The array of items in the dropdown list. See List for details.
     */
    items: Control.chain( "$list", "items", function() { this._updateItemContents(); } ),
    
    /*
     * A mapping of items to controls and back. See List for details.
     */
    mapFunction: Control.chain( "$list", "mapFunction" ),
    
    initialize: function() {
        
        this._super();
        this.genericIfClassIs( ListComboBox );
        
        // Clicking an item in the list puts its content into the text box portion.
        var self = this;
        this.$list().on({
            
                click: function( event ) {
                    var $closestItem = $( event.target ).closest( self.$list().children() );
                    if ( $closestItem ) {
                        var itemContent = $closestItem.control().content();
                        self
                            .content( itemContent )
                            .close();
                    }
                },
                
                keydown: function( event ) {
                    if ( event.which === 13 /* Enter */) {
                        if ( self.opened() ) {
                            self.close();
                            event.stopPropagation();
                            event.preventDefault();
                        }
                    }
                },
                
                selectionChanged: function() {
                    var selectedControl = self.$list().selectedControl();
                    if ( selectedControl ) {
                        var content = selectedControl.content();
                        if ( content !== self.content() ) {
                            self.content( content );
                            self._selectText( 0, content.length );
                        }
                    }
                }
                
            });
        
        if ( !this.itemClass() ) {
             this.itemClass( BasicButton );
        }
    },
    
    /*
     * The class which should be used to render the list items as controls.
     */
    itemClass: Control.property[ "class" ]( function( itemClass ) {
        this.$list().itemClass( itemClass );
    }),
    
    open: function() {

        // See if current text is in the list and, if so, select it.
        var content = this.content();
        var index = $.inArray( content, this._itemContents() );
        if ( index >= 0 ) {
            this.$list().selectedIndex( index );
        }
        
        var result = this._super();
        
        // Give the input control focus if it doesn't already have it.
        var inputElement = this.inputElement();
        if ( document.activeElement !== inputElement[0] ) {
            this.inputElement().focus();
        }
        
        return result;
    },
    
    // Try to auto-complete the current text against the item contents.
    _autoComplete: function() {
        
        var content = this.content();
        
        var match = this._matchingItem( content );
        if ( !match ) {
            this.$list().selectedControl( null );
            return;
        }

        this.content( match );
        
        // Select the auto-completed text.
        this._selectText( content.length, match.length );
        
        this._selectTextInList();
    },
    
    _bindContentEvents: function() {
        
        this._super();
        
        // See notes at _contentKeydown.
        var self = this;
        this.inputElement().keydown( function( event ) {
            self._contentKeydown( event );
        });
    },
    
    /*
     * Handle a keydown event. Keydown gives the best AutoComplete performance
     * and behavior: among other things, the AutoComplete happens as soon as
     * the user begins typing. However, using keydown creates a problem that
     * the input control's content won't actually reflect the effects key the
     * user just pressed down. So we set a timeout to give the keydown event a
     * chance to bubble up and do its work, then do our AutoComplete work
     * against the resulting text.
     */
    _contentKeydown: function( event ) {
        
        var handled = false;
        var navigationKeys = [
            33, // Page Up
            34, // Page Down
            38, // Up
            40 // Down
        ];
        var self = this;
        
        // Do AutoComplete on Space, or characters from zero (0) and up,
        // ignoring any combinations that involve Alt or Ctrl.
        if ( ( event.which === 32 || event.which >= 48 ) 
            && !( event.altKey || event.ctrlKey || event.metaKey) ) {

            this._setTimeout( function() { self._autoComplete(); });
            
        } else if ( this.opened() && $.inArray( event.which, navigationKeys ) >= 0 ) {
            
            // Forward navigation keys to opened list.
            this.$list().trigger( event );
            handled = true;

        } else if ( event.which === 8 || event.which === 46 ) {
            
            // On Backspace or Delete, clear list select if text is empty.
            this._setTimeout( function() {
                self._selectTextInList();
            });
            
        } else if ( event.which === 40 ) {
            
            // Pressing Down when list is closed will open list.
            this.open();
            
            // If the input text is empty, select the first list item.
            var content = this.content();
            if ( content == null || content.length === 0 ) {
                this.$list().selectedIndex( 0 );
            }

            handled = true;
            
        }
        
        if ( handled ) {
            event.stopPropagation();
            event.preventDefault();
        }
    },

    _itemContents: Control.property(),
    
    // Return the item whose prefix matches the given string, ignoring case.
    // Return null if not found.
    _matchingItem: function( s ) {
        var length = s.length;
        if ( length > 0 ) {
            var lower = s.toLowerCase();
            var itemContents = this._itemContents();
            for ( var i = 0, itemCount = itemContents.length; i < itemCount; i++ ) {
                var itemContent = itemContents[i]; 
                if ( length <= itemContent.length
                    && itemContent.substr( 0, length ).toLowerCase() === lower ) {
                    return itemContent;
                }
            }
        }
        return null;
    },

    // Select the current input text in the list if it's there.
    // Clear the list selection if the text is not found.
    _selectTextInList: function() {
        if ( this.opened() ) {
            var content = this.content();
            var index = $.inArray( content, this._itemContents() );
            this.$list().selectedIndex( index );
        }
    },
    
    // Arrange for a callback to be performed via a timeout.
    // See notes at _contentKeydown.
    _setTimeout: function( callback ) {
        
        // Cancel any pending AutoComplete timeout.
        var timeout = this._timeout();
        if ( timeout ) {
            clearTimeout( timeout );
        }
        
        // Queue a new timeout.
        var self = this;
        timeout = window.setTimeout( callback, 50 );
        this._timeout( timeout );
    },
    
    _timeout: Control.property(),
    
    /*
     * Extract a copy of all the items so we can match against them when
     * the user types. We get the contents from the list's controls, rather
     * than from the list's items() property, since the items could be
     * arbitrary JavaScript objects. Once the list's mapFunction has mapped
     * those objects into the controls, the controls' content should best
     * reflect the text to map against. 
     */
    _updateItemContents: function() {
        var itemContents = [];
        this.$list().controls().eachControl( function( index, $control ) {
            itemContents.push( $control.content() );
        });
        this._itemContents( itemContents );
    }

});
</script>

</Control>
