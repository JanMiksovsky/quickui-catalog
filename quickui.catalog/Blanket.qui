<!--
A "blanket" that covers the entire viewport, typically to swallow clicks.
-->

<Control className="Blanket">

<style>
{
    background: black;
    cursor: default;
    position: fixed;
    opacity: 0.2;       /* TODO: Remove */
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
}
</style>

<script>
Blanket.prototype.extend({
    
    /*
     * Add the blanket to the DOM such that it ends up behind the target
     * element and in front of everything else (within that element's
     * stacking context).
     */
    lift: function( $target ) {
        
        var targetCss = {
            position: $target.css( "position" ),
            "z-index": $target.css( "z-index" )
        };
        
        var targetPreviousCss = {};
        if ( targetCss.position === "static" ) {
            /*
             * Give the target relative positioning so its z-index will work.
             */
            targetPreviousCss.position = ( targetCss.position !== "static" )
                ? targetCss.position
                : "";
            $target.css( "position", "relative" );
        }
        
        var targetZIndex = parseInt( targetCss[ "z-index" ] ); 
        if ( isNaN( targetZIndex ) ) {
            /*
             * The target doesn't have a z-index, so we'll temporarily assign
             * a z-index of zero so it at least ends up above all other elements
             * with no z-index within the target's stacking context.
             */
            targetPreviousCss[ "z-index" ] = ( targetCss[ "z-index" ] !== "auto" )
                ? targetCss[ "z-index" ]
                : "";
            targetZIndex = 0;
            $target.css( "z-index", targetZIndex );
        }
        
        return this
            ._target( $target )
            ._targetPreviousCss( targetPreviousCss )
            .css({
                "z-index": targetZIndex
            })
            .insertBefore( $target );
    },
    
    restore: function() {
        var $target = this._target();
        if ( $target ) {
            // Undo any CSS we've applied
            var targetCss = this._targetPreviousCss();
            if ( targetCss.position ) {
                $target.css( "position", targetCss.position );
            }
            if ( targetCss[ "z-index" ] ) {
                $target.css( "z-index", targetCss[ "z-index" ] );
            }
            this
                ._target( null )
                ._targetPreviousCss( null );
        }
        return this;
    },
    
    /*
     * Return the closest parent with a "position" and "z-index" attributes.
     * If none if found, return the document body. 
     */
    _findStackingContext: function( $element ) {
        for ( var context = $element.parent(); context[0] !== document.body; context = context.parent() ) {
            if ( context.css( "z-index" ) !== "auto" && context.css( "position" ) !== "static" ) {
                break;
            }
        }
        return context;
    },

    /*
     * Return the maximum Z-index in use within the indicated stacking context.
     */
    _maximumZIndexWithin: function( $context )
    {
        var topLevelElements = $( "body" ).children().andSelf();
        var zIndices = $.map( topLevelElements, function( element ) {
            switch ( $(element).css("position") ) {
                case "absolute":
                case "fixed":
                    var zIndex = parseInt( $( element ).css( "z-index" ) ) || 1;
                    return zIndex;
            }
        });
        return Math.max.apply( null, zIndices );
    },
    
    _findSubcontexts: function( $context ) {
        
    },
    
    _target: Control.property(),
    
    _targetPreviousCss: Control.property()
    
});
</script>

</Control>