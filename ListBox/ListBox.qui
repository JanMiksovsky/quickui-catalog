<!--
A list box that allows single and multiple selection.
The user can select items with the mouse and keyboard.
-->

<Control name="ListBox">

<prototype>
    <List itemClass="ButtonBase" />
</prototype>

<style>
{
    overflow-y: auto;
}

> * {
    display: block;
    outline: none;
}

/* Generic appearance */
.ListBox.generic {
    border: 1px solid lightgray;
    -moz-box-sizing: border-box;
    -ms-box-sizing: border-box;
    -webkit-box-sizing: border-box;
    box-sizing: border-box;
}

.ListBox.generic .ButtonBase.generic {
    border: none;
    width: 100%;
}
.ListBox.generic .ButtonBase.generic.selected {
    background: highlight;
    color: highlighttext;
}
</style>

<script>
ListBox.prototype.extend({
    
    initialize: function() {
        
        this._super();
        this.genericIfClassIs( ListBox );
        
        /*
         * Try to convince the browser that the list is focusable, but without
         * forcing it into the tab order (as a positive tabindex would do).
         */
        this.attr( "tabindex", "-1" );
        
        var self = this;
        this.on("click", function( event ) {
                var child = self._getControlContainingElement( event.target );
                if ( child ) {
                    self._controlClick( child );
                }
            })
            .on("keydown", function( event ) {
                self._keydown( event );
            });
    },
    
    /*
     * The control in the list which is currently selected.
     */
    selectedControl: Control.iterator( function( selectedControl ) {
        if ( selectedControl === undefined ) {
            return this.controls().filter( ".selected" ).eq(0);
        } else {
            var previousControl = this.selectedControl();
            this.controls()
                .removeClass( "selected" )
                .filter( selectedControl )
                .addClass( "selected" );
            this._scrollToControl( selectedControl );
            if ( selectedControl !== previousControl ) {
                this.trigger( "selectionChanged" );
            }
        }
    }),
    
    /*
     * The index of the currently-selected control.
     */
    selectedIndex: Control.iterator( function( selectedIndex ) {
        if ( selectedIndex === undefined ) {
            var control = this.selectedControl();
            return control
                ? this.controls().index( control )
                : -1;
        } else {
            var index = parseInt( selectedIndex );
            var control = ( index >= 0 )
                ? this.controls().eq( index )
                : null;
            this.selectedControl( control );
        }
    }),
    
    /*
     * The item represented by the currently-selected control.
     */
    selectedItem: Control.iterator( function( selectedItem ) {
        if ( selectedItem === undefined ) {
            var index = this.selectedIndex();
            return index >= 0
                ? this.items()[ index ]
                : null;
        } else {
            var index = $.inArray( selectedItem, this.items() );
            this.selectedIndex( index );
        }
    }),
    
    _controlClick: function( control ) {
        this.selectedControl( control );
    },
    
    _getControlContainingElement: function( element ) {
        return $( element ).closest( this.controls() ).control();
    },
    
    /*
     * Return the control that spans the given y position, or -1 if not found.
     * If "first" is true, prefer the first control at that position; if false,
     * prefer the last.
     */
    _getControlAtY: function( y, first ) {
        
        if ( first === undefined ) {
            first = true;
        }

        var controls = this.controls();
        var start = first ? 0 : controls.length - 1;
        var end = first ? controls.length : 0;
        var step = first ? 1 : -1;
        for ( var i = start; i !== end; i += step ) {
            var $control = controls.eq(i);
            var controlTop = Math.round( $control.offset().top );
            var controlBottom = controlTop + $control.outerHeight();
            if ( controlTop <= y && controlBottom >= y ) {
                return i;
            }
        }
        
        return -1;
    },
    
    _keydown: function( event ) {
        
        var handled;
        switch ( event.which ) {
            
            case 33: // Page Up
                handled = this._pageUp();
                break;
                
            case 34: // Page Down
                handled = this._pageDown();
                break;
            
            case 35: // End
                handled = this._selectLastControl();
                break;
            
            case 36: // Home
                handled = this._selectFirstControl();
                break;
            
            case 37: // Left
            case 38: // Up
                handled = event.altKey
                    ? this._selectFirstControl()
                    : this._selectPreviousControl();
                break;
                
            case 39: // Right
            case 40: // Down
                handled = event.altKey
                    ? this._selectLastControl()
                    : this._selectNextControl();
                break;
                
            default:
                handled = false;
                break;
        }
        
        if (handled)
        {
            event.stopPropagation();
            event.preventDefault();
        }
    },
    
    _pageDown: function() {

        var scrollTop = this.scrollTop();
        var selectedIndex = this.selectedIndex();
        
        // Find the control at the bottom of the viewport.
        var viewPortDimensions = this._viewPortDimensions();
        var index = this._getControlAtY( viewPortDimensions.bottom );
        if ( index >= 0 && selectedIndex === index ) {
            // Last visible control is currently selected; find which control
            // is one page height below the viewport.
            index = this._getControlAtY( viewPortDimensions.bottom + viewPortDimensions.height );
        }

        if ( index < 0 ) {
            // Would scroll past last control, so just select last control.
            return this._selectLastControl();
        }
        
        if ( index !== this.selectedIndex() ) {
            this.selectedIndex( index );
            return true;
        }
        
        return false;
    },
    
    _pageUp: function() {

        var viewPortHeight = this.height();
        var selectedIndex = this.selectedIndex();
        
        // Find the control at the top of the viewport.
        var viewPortDimensions = this._viewPortDimensions();
        var index = this._getControlAtY( viewPortDimensions.top, false );
        if ( index >= 0 && selectedIndex === index ) {
            // First visible control is currently selected; find which control
            // is one page height above the view port.
            index = this._getControlAtY( viewPortDimensions.top - viewPortDimensions.height, false );
        }

        if ( index < 0 ) {
            // Would scroll above first control, so just select first control.
            return this._selectFirstControl();
        }
        
        if ( index !== this.selectedIndex() ) {
            this.selectedIndex( index );
            return true;
        }
        
        return false;
    },
    
    _scrollToControl: function( $control ) {
        
        var controlTop = $control.offset().top;
        var controlBottom = controlTop + $control.outerHeight();

        var viewPortDimensions = this._viewPortDimensions();
        var scrollTop = this.scrollTop();
        
        if ( controlBottom > viewPortDimensions.bottom ) {
            // Scroll up until control is entirely visible.
            this.scrollTop( scrollTop + controlBottom - viewPortDimensions.bottom );
        } else if ( controlTop < viewPortDimensions.top ) {
            // Scroll down until control is entirely visible.
            this.scrollTop( scrollTop - ( viewPortDimensions.top - controlTop ) );
        }
    },
    
    _selectFirstControl: function() {
        if ( this.controls().length > 0 ) {
            this.selectedIndex( 0 );
            return true;
        }
        return false;
    },
    
    _selectLastControl: function() {
        if ( this.controls().length > 0 ) {
            this.selectedIndex( this.controls().length - 1 );
            return true;
        }
        return false;
    },
    
    _selectNextControl: function() {
        var index = this.selectedIndex() + 1;
        if ( index < this.controls().length ) {
            this.selectedIndex( index );
            return true;
        }
        return false;
    },
    
    _selectPreviousControl: function() {
        var index = this.selectedIndex() - 1;
        if ( index >= 0 && this.controls().length > 0 ) {
            this.selectedIndex( index );
            return true;
        }
        return false;
    },
    
    _viewPortDimensions: function() {
        var viewPortTop = this.offset().top;
        var viewPortHeight = this.height();
        return {
            top: viewPortTop,
            height: viewPortHeight,
            bottom: viewPortTop + viewPortHeight
        };
    }
    
});
</script>

</Control>
