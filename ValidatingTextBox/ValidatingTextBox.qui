<!--
Validates textual input using an asymmetric validation scheme.
This applies a validation function while the user is typing, when the
control loses focus, or when a validate() method is called.

The validation is considered asymmetric because the control behaves differently
in an error state than when not in an error state:
1. If the control is not yet in an error state, the control's validity is not
reflected until the focus leaves the control. That is, the input is assumed
to be good until the user has moved on.
2. If the control is already in an error state, the control's validity is
reflected immediately upon detecting valid input. That is, the error is
forgiven without requiring that the user moves the focus away.

For more discussion: http://miksovsky.blogs.com/flowstate/2010/09/index.html.
-->

<Control name="ValidatingTextBox">

<prototype>
    <TextBox/>
</prototype>

<style>
/* Generic appearance */

.ValidatingTextBox.generic.invalid #textBox {
    background-color: pink;
}
</style>

<script>
ValidatingTextBox.prototype.extend({
    
    invalid: Control.chain( "applyClass/invalid" ),
    
    initialize: function() {
        
        this._super();
        this.genericIfClassIs( ValidatingTextBox );
        
        var self = this;
        this.$textBox().bind({
            "blur": function() {
                self.validate( true );
            },
            "keyup": function() {
                self.validate();
            }
        });
    },
    
    /*
     * Check to see if the control's contents are valid.
     * If the strict parameter is true, then apply the invalid state if the
     * contents are invalid. If the strict parameter is false, then the
     * control can move out of the invalid state (if the contents are now valid),
     * but can't move into the invalid state.
     */
    validate: Control.iterator( function( strict ) {
        var valid = this.valid();
        if ( strict || this.invalid() ) {
            this.invalid( !valid );
        }
    }),
    
    /*
     * True if the field must be non-empty.
     */
    required: Control.property.bool( function() {
        this.validate();
    }),
    
    /*
     * Returns true if the control's contents are valid.
     * The default implementation simply looks as the required() property and,
     * if true, ensures the content is non-empty.
     *  
     * Subclasses can override this to validate their contents. E.g.:
     * 
     *  valid: function() {
     *      var valid = this._super();
     *      valid = valid && ... Perform additional checks here ...
     *      return valid;
     *  }
     */
    valid: function() {
        var valid;
        if ( this.required() )
        {
            var content = this.content();
            valid = !!content && content.length > 0;
        } else {
            valid = true;
        }
        return valid;
    }
});
</script>

</Control>