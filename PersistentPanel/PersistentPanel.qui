<!--
A panel that can be situated in a vertically scrolling container, and which
will move up and down in the viewport, but will bump up against the top of
the viewport and remain visible instead of scrolling out of view.

The control hosts its content within a panel that can pop out of the layout
flow. To faciliate styling, the control exposes background and padding
properties that map to the corresponding properties on this inner panel.
For most complex content styling, set all content elements within a single
div or other element and style that.
-->

<Control name="PersistentPanel">

<content>
    <div id="PersistentPanel_content"/>
</content>

<style>
{
    box-sizing: border-box;
    -moz-box-sizing: border-box;
    -ms-box-sizing: border-box;
    -webkit-box-sizing: border-box;
}

#PersistentPanel_content {
    box-sizing: border-box;
    -moz-box-sizing: border-box;
    -ms-box-sizing: border-box;
    -webkit-box-sizing: border-box;
}

.PersistentPanel.fixed #PersistentPanel_content {
    position: fixed;
}

/* Generic appearance */
.PersistentPanel.generic #PersistentPanel_content {
    background: white;
}
</style>

<script>
PersistentPanel.prototype.extend({

    /*
     * The content's background. See top notes.
     */    
    background: Control.chain( "$PersistentPanel_content", "css/background" ),
    
    /*
     * The control's content.
     */
    content: Control.chain( "$PersistentPanel_content", "content", function() {
        if ( this.inDocument() ) {
            this._resize();
            this.trigger( "sizeChanged" );
        }
    }),
    
    /*
     * The content's padding. See top notes.
     */
    padding: Control.chain( "$PersistentPanel_content", "css/padding" ),
    
    initialize: function() {
        
        this.genericIfClassIs( PersistentPanel );
        
        this.inDocument( function( $control ) {
            if ( !$control.scrollingParent() ) {
                // No scrolling parent has been set; look for one.
                $control.scrollingParent( $control._findScrollingParent() );
            }
            $control._resize();
        });

        var self = this;
        $( window ).resize( function() {
            self._resize();
        });
    },
    
    /*
     * The parent of this control used to determine whether the control is
     * in or out of view. The default value for this property is the closest
     * parent element with overflow-y set to "auto" or "scroll".
     */
    scrollingParent: Control.property( function( scrollingParent ) {
        var self = this;
        $( scrollingParent ).scroll( function() {
            self._scrollingParentScrolled();
        });
    }),

    _adjustSizes: function() {
        
        // Make the panel the same width as the container.
        this.$PersistentPanel_content().width( this.width() );
        
        // Make the container the same height as the panel, so that when
        // the panel pops out in fixed mode, the container can continue
        // to occupy the same amount of vertical space.
        this.height( this.$PersistentPanel_content().outerHeight( true ) );
    },
    
    /*
     * Determine which parent of the control scrolls vertically.
     */
    _findScrollingParent: function() {
        
        // By default, assume the window is what is scrolling.
        var scrollingParent = window;
        
        var parents = this.parents();
        for ( var i = 0; i < parents.length; i++ ) {
            
            if ( parents[i] === document.body ) {
                /*
                 * It doesn't appear possible to bind to the scroll event
                 * for the document body. Instead, if the body is the
                 * scrolling parent, we use the window instead, which has
                 * the same effect.
                 */
                break;
            }
            
            var overflowY = parents.eq(i).css( "overflow-y" );
            if ( overflowY === "auto" || overflowY === "scroll" ) {
                // Found a parent that explicitly asks for scrolling; use that.
                scrollingParent = parents[i];
                break;
            }
        }
        
        return scrollingParent;
    },
    
    _resize: function() {
        
        console.log( "_resize" );
        
        // A change in width could have caused the contents to change in height,
        // or the container to change in width.
        this._adjustSizes();
        
        // A resize could easily have caused the container's position to
        // move in or out of view, so we treat it like a scroll.
        this._scrollingParentScrolled();
        
    },

    /*
     * Do the real work of the control: determine whether the panel contents
     * should flow with the document, or pop out into a fixed position.
     */
    _scrollingParentScrolled: function() {
        var scrollingParent = this.scrollingParent();
        if ( scrollingParent ) {
            
            var isScrollingParentWindow = ( scrollingParent === window );
            var $scrollingParent = $( scrollingParent );
            //var scrollTop = isScrollingParentWindow
            //    ? 0
            //    : $scrollingParent.scrollTop();
            var scrollTop = $scrollingParent.scrollTop();
            var containerTop = this.position().top;
            var isContainerInViewport = ( containerTop >= scrollTop );
            console.log( scrollTop + " " + containerTop + " " + isContainerInViewport );

            // Position the panel at the top of the viewport.
            var viewPortTop = isScrollingParentWindow
                ? 0
                : $scrollingParent.offset().top;
            this.$PersistentPanel_content().css( "top",
                isContainerInViewport ? "" : viewPortTop + "px" );

            this.toggleClass( "fixed", !isContainerInViewport );
        }
    }
    
});
</script>

</Control>