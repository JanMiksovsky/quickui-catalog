<!--
A panel arranging items horizontally; items that don't fit overflow into a menu.

The basic strategy is to keep all items on the same line, but make the ones
that don't fit invisible. When the menu button is clicked, the invisible items
are temporarily moved to the menu, then moved back when the menu is closed. 
-->

<Control name="PanelWithOverflow">

<prototype>
    <Layout>
        <HasPopup id="menuButton" closeOnInsideClick="true" openOnClick="true">
            <ButtonBase id="PanelWithOverflow_indicator">Â»</ButtonBase>
        </HasPopup>
        <div id="PanelWithOverflow_content"/>
    </Layout>
</prototype>

<style>
{
    position: relative;
}

#PanelWithOverflow_content {
    overflow: hidden;
    white-space: nowrap;
}

/* By default, contents are arranged in inline layout */
#PanelWithOverflow_content > * {
    display: inline-block;
}
#PanelWithOverflow_content > .overflowed {
    visibility: hidden;
}

#OverflowPanel_menu {
    float: right;
}

/* In the menu, contents layout switches to vertical arrangement. */
#OverflowPanel_menu #HasPopup_popup > * {
    display: block;
}
</style>

<script>
PanelWithOverflow.prototype.extend({
    
    /*
     * The contents of the control.
     */
    content: Control.chain( "$PanelWithOverflow_content", "content", function() {
        this.layout();
    }),
    
    /*
     * The indicator used to show when contents have overflowed
     * the contorl's bounds.
     */
    indicator: Control.chain( "$PanelWithOverflow_indicator", "content", function() {
        this.layout();
    }),
    
    initialize: function() {
        
        this.genericIfClassIs( PanelWithOverflow );
        this._super();
        
        var self = this;
        this.$menuButton().on({
            "canceled closed": function() { self._menuClosed(); },
            "opened": function() { self._menuOpened(); }
        });
    },
    
    /*
     * Force the control to layout its contents.
     */
    layout: Control.iterator( function() {
        
        // Don't bother laying out until we're visible, or if the popup
        // is currently open. The latter case, while it'd be nice to support,
        // quickly gets quite hairy.
        if ( !this.is( ":visible" ) || this.$menuButton().opened() ) {
            return;
        }
        
        var availableWidth = this.width();
        var showMenu = false;
        var $children = this.$PanelWithOverflow_content().children();
        
        // Work from right to left 
        for ( var i = $children.length - 1; i > 0; i-- ) {
            var $child = $children.eq(i);
            // Look at right edge, not counting right margin
            var right = $child.position().left + $child.outerWidth() +
                        parseInt( $child.css( "margin-left" ) );
            var overflowed = ( right > availableWidth );
            $child.toggleClass( "overflowed", overflowed );
            if ( overflowed ) {
                if ( !showMenu ) {
                    // Turn on menu, and allocate room for it.
                    showMenu = true;
                    availableWidth -= this.$menuButton().outerWidth( true );
                }
            } else {
                // Everything to the left fits.
                $children.slice( 0, i ).removeClass( "overflowed" );
                break;
            }
        }
        
        this.$menuButton().toggle( showMenu );
    }),
    
    _menuClosed: Control.iterator( function() {
        // Return the overflow menu's children to the main content area.
        var $overflowed = this.$menuButton().popup();
        this.$PanelWithOverflow_content().append( $overflowed );
        this.layout();
    }),
    
    _menuOpened: Control.iterator( function() {
        // Temporarily move the overflowed items into the menu.
        var content = this.$PanelWithOverflow_content().content();
        var $overflowed = $( content ).filter( ".overflowed" );
        this.$menuButton().popup( $overflowed );
    })

});
</script>

</Control>