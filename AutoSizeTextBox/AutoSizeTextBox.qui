<!--
A text box that makes itself big enough to show its content.
This works by copying the text to a hidden div which will automatically grow in size;
the expanding copy will expand the container, which in turn stretch the text box.
-->

<Control name="AutoSizeTextBox">

<content>
    
    <!-- Visible text box -->
    <textarea id="textBox"/>
    
    <!-- Hidden copy of text. Use a pre tag to preserve line breaks, entities, etc. -->
    <pre id="textCopy"/>
    
</content>

<style>
{
    position: relative;
}

#textBox {
    box-sizing: border-box;
    -moz-box-sizing: border-box;
    -ms-box-sizing: border-box;
    -webkit-box-sizing: border-box;
    height: 100%;
    overflow: hidden;
    position: absolute;
    resize: none;
    top: 0;
    width: 100%;
}

#textCopy {
    box-sizing: border-box;
    -moz-box-sizing: border-box;
    -ms-box-sizing: border-box;
    -webkit-box-sizing: border-box;
    visibility: hidden;
    white-space: pre-wrap; /* So lines wrap */
    width: 100%;
}
</style>

<script>
AutoSizeTextBox.prototype.extend({
    
    initialize: function() {
        var self = this;
        this.$textBox().bind( "change keydown keyup", function() {
            self.autoSize();
        });
        this.inDocument( function( $control  ) {
            $control._refresh();
        });
    },

    // Resize the text box to exactly contain its content.
    autoSize: Control.iterator( function() {        
        // Copy text box contents; browser will calculate correct height of copy,
        // which will make overall control taller, which will make text box taller.
        this.$textCopy().text( this.$textBox().content() );
    }),
    
    content: Control.chain( "$textBox", "content", function() {
        this.autoSize();
    }),
    
    /*
     * The minimum number of lines that should be shown.
     * The default value of 2 creates a textarea at least two lines
     * tall, which helps the user intuit the ability to type multiple
     * lines of text.
     */
    minimumLines: Control.property.integer( function( minimumLines ) {
        if ( this.inDocument() ) {
            this._refresh();
        }
    }, 2 ),
    
    // For the following, we need to wait until the control's in the DOM.    
    _refresh: Control.iterator( function() {

        var $textBox = this.$textBox();
        var $textCopy = this.$textCopy();
        
        // Copy the control's font to the textarea and text copy.
        // This ensures both end up with the same text metrics.
        this.children().css({
            "font-family": this.css( "font-family" ),
            "font-size": this.css( "font-size" ),
            "font-style": this.css( "font-style" ),
            "font-weight": this.css( "font-weight" )
        });

        // Try to get the text box's line height. Unfortunately some browsers
        // return the useful value "normal", in which case we have to make
        // an estimate based on font size.
        var lineHeight = parseInt( $textBox.css( "line-height" ) );
        if ( isNaN( lineHeight ) ) {
            // line-height values like "normal" don't give us a measurement
            // we can use. We fall back to estimating a line height
            // based on font size. We then apply this to both the text box
            // and the copy so they both have the same font-size.
            lineHeight = Math.floor( parseInt( $textBox.css( "font-size" ) ) * 1.25 );
            $textBox.css( "line-height", lineHeight + "px" );
        } 
        $textCopy.css( "line-height", lineHeight + "px" );
        
        // Mirror the textarea's padding on the text copy.
        // Also add an extra line on the bottom so user sees they have more room.
        // NOTE: Firefox seems to report 0px padding for the text box, even when there
        // appears to be 1px padding on a standard textarea. WebKit gets this right.
        // Perhaps there's some way in Firefox to detect and correct the error, but
        // for the time being this seems to work okay.
        var paddingBottom = parseInt( $textBox.css( "padding-bottom" ) );
        $textCopy.css({
            "padding-bottom": ( paddingBottom + lineHeight ) + "px",  
            "padding-left": $textBox.css( "padding-left" ),
            "padding-right": $textBox.css( "padding-right" ),
            "padding-top": $textBox.css( "padding-top" )
        });

        var minimumLines = this.minimumLines();
        if ( minimumLines ) {
            // Convert the number of lines into a minimum height;
            // If anyone knows a more accurate way to do this without
            // using a magic constant, please fix!
            var height = Math.round( 1.15 * minimumLines * lineHeight );
            this.css( "min-height", height + "px" );
        }
    })
    
});
</script>

</Control>
