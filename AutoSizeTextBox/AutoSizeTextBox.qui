<!--
A text box that makes itself big enough to show its content.
This works by copying the text to a hidden div whose height can be measured.
-->

<Control name="AutoSizeTextBox">

<content>
    <textarea id="textBox"/>
    <MultiLineText id="textCopy"/>
</content>

<style>
{
    position: relative;
}

#textBox {
    box-sizing: border-box;
    -moz-box-sizing: border-box;
    -ms-box-sizing: border-box;
    -webkit-box-sizing: border-box;
    height: 100%;
    overflow: hidden;
    position: absolute;
    resize: none;
    top: 0;
    width: 100%;
}

#textCopy {
    box-sizing: border-box;
    -moz-box-sizing: border-box;
    -ms-box-sizing: border-box;
    -webkit-box-sizing: border-box;
    visibility: hidden;
    width: 100%;
}
</style>

<script>
AutoSizeTextBox.prototype.extend({
    
    /*
     * The minimum number of lines that should be shown.
     * The default value of 2 creates a textarea at least two lines
     * tall, which helps the user intuit the ability to type multiple
     * lines of text.
     */
    minimumLines: Control.property.integer( null, 2 ),
    
    initialize: function() {
        var self = this;
        this.$textBox().bind( "change keydown keyup", function() {
            self.autoSize();
        });
    
        // For the following, we need to wait until the control's in the DOM.    
        this.inDocument( function( $control  ) {
            
            // Copy the control's font to the textarea. The text copy will 
            // automatically pick up the control's font, but the textarea won't.
            var $textBox = $control.$textBox();
            $textBox.css({
                "font-family": self.css( "font-family" ),
                "font-size": self.css( "font-size" ),
                "font-style": self.css( "font-style" ),
                "font-weight": self.css( "font-weight" )
            });
            
            // Mirror the textarea's padding on the text copy.
            // Also add an extra line on the bottom so user sees they have more room.
            var paddingBottom = parseInt( $textBox.css( "padding-bottom" ) );
            var lineHeight = this._lineHeight();
            $control.$textCopy().css({
                "padding-bottom": ( paddingBottom + lineHeight ) + "px",  
                "padding-left": $textBox.css( "padding-left" ),
                "padding-right": $textBox.css( "padding-right" ),
                "padding-top": $textBox.css( "padding-top" )
            });

            var minimumLines = this.minimumLines();
            if ( minimumLines ) {
                // Convert the number of lines into a minimum height;
                // If anyone knows a more accurate way to do this without
                // using a magic constant, please fix!
                var height = Math.round( 1.15 * minimumLines * this._lineHeight() );
                this.css( "min-height", height + "px" );
            }
        });
    },

    // Resize the text box to exactly contain its content.
    autoSize: function() {        
        // Copy text box contents; browser will calculate correct height of copy,
        // which will make overall control taller, which will make text box taller.
        this.$textCopy().content( this.$textBox().content() );
    },
    
    content: Control.chain( "$textBox", "content", function() {
        this.autoSize();
    }),

    /*
     * Try to get the text box's line height. Unfortunately some browsers
     * return the useful value "normal", in which case we have to make
     * an estimate based on font size.
     */    
    _lineHeight: function() {
        var $textBox = this.$textBox();
        return $textBox.css( "line-height" ) !== "normal"
            ? parseInt( $textBox.css( "line-height" ) )
            : Math.floor( parseInt( $textBox.css( "font-size" ) ) * 1.25 );        
    }
    
});
</script>

</Control>
