<!-- Text box that parses dates -->

<Control name="DateTextBox">

<prototype>
    <ValidatingTextBox/>
</prototype>

<style>
#textBox {
    width: 6em;
}
</style>

<script>
DateTextBox.prototype.extend({
    
    _previousDate: Control.property.date(),
    
    initialize: function() {
        
        this._super();
        this.genericIfClassIs( DateTextBox );
        
        var self = this;
        this.$textBox().blur( function() {
            self._refresh();
        });
    },

    culture: function( culture ) {
        var result = this._super( culture );
        if ( culture !== undefined ) {
            this._refresh();
        }
        return result;
    },

    date: Control.property.date( function( date ) {
        var previousDate = this._previousDate();
        var previousTime = previousDate && previousDate.getTime();
        var time = date && date.getTime();
        var dateChanged = ( previousTime !== time ); 
        if ( !dateChanged ) {
            this
                ._previousDate( date )
                .trigger( "dateChanged", [ date ] );
        }
    }),
    
    valid: function() {

        var valid = this._super();

        var content = this.content();
        if ( !!content ) {
            var date = this._parseDate( content );
            this.date( date );
            valid = valid && !!date;
        }
        
        return valid;
    },
    
    
    // Return the separator between dates.
    _dateSeparator: function() {
        var culture = this.culture();
        var calendar = culture ? culture.calendar : DateTextBox;
        return calendar[ "/" ];
    },
    
    _formatDate: function( date ) {
        var culture = this.culture();
        var formattedDate;
        if ( culture ) {
            formattedDate = Globalize.format( date, culture.calendar.patterns.d, culture );
        } else {
            formattedDate = (date.getMonth() + 1) + 
                this._dateSeparator() + date.getDate() +
                this._dateSeparator() + date.getFullYear();
        }
        return formattedDate;
    },
    
    /*
     * Basic date parser.
     * Parses the given text as a date and return the result.
     * Returns null if the text couldn't be parsed.
     * 
     * In addition to formats supported by the standard Date.parse(),
     * this also handles a short year ("1/1/12") or missing year ("1/1").
     */
    _parseDate: function( text ) {
        
        var dateSeparator = this._dateSeparator();
        var parts = text.split( dateSeparator );
        var currentYear = ( new Date() ).getFullYear().toString();
        
        var munged;
        if ( parts.length === 2 ) {
            // Add on year
            munged = text + dateSeparator + currentYear;
        } else if ( parts.length === 3 && parts[2].length == 2 ) {
            // Convert short year to long year
            var fullYear = currentYear.substring(0, 2) + parts[2];
            munged = parts[0] + dateSeparator
                   + parts[1] + dateSeparator
                   + fullYear;
        } else {
            // Parse as is
            munged = text;
        }
        
        var milliseconds = Date.parse( munged );
        return isNaN( milliseconds )
            ? null
            : new Date(milliseconds);
    },
    
    _refresh: function() {
        var date = this.date();
        if ( !!date ) {
            var formattedDate = this._formatDate( date );
            if ( formattedDate !== this.content() ) {
                this.content( formattedDate );
            }
        }
        return this;
    }
    
});

/*
 * Class properties.
 * When Globalize is not present, these offer the U.S. English defaults.
 * See the Globalize documentation (https://github.com/jquery/globalize)
 * for details.
 */
DateTextBox.extend({
	
	"/": "/",
	
	patterns: {
        // short date pattern
		d: "M/d/yyyy",
	},
	
	twoDigitYearMax: 2029
	
});
</script>

</Control>
