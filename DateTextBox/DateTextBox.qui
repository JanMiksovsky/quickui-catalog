<!-- Text box that parses dates -->

<Control name="DateTextBox">

<prototype>
    <ValidatingTextBox/>
</prototype>

<style>
#textBox {
    width: 6em;
}
</style>

<script>
DateTextBox.prototype.extend({
    
    _previousDate: Control.property.date(),
    
    initialize: function() {
        
        this._super();
        this.genericIfClassIs( DateTextBox );
        
        var self = this;
        this.$textBox().blur( function() {
            self._refresh();
        });
    },

    culture: function( culture ) {
        var result = this._super( culture );
        if ( culture !== undefined ) {
            this._refresh();
        }
        return result;
    },

    date: Control.property.date( function( date ) {
        var previousDate = this._previousDate();
        var previousTime = previousDate && previousDate.getTime();
        var time = date && date.getTime();
        var dateChanged = ( previousTime !== time ); 
        if ( !dateChanged ) {
            this
                ._previousDate( date )
                .trigger( "dateChanged", [ date ] );
        }
    }),
    
    valid: function() {

        var valid = this._super();

        var content = this.content();
        if ( !!content ) {
            var date = this._parseDate( content );
            this.date( date );
            valid = valid && !!date;
        }
        
        return valid;
    },
    
    /*
     * Use a culture's "short date" pattern (e.g., "M/d/yyyy") to determine an
     * abbreviated date that omits the year (e.g., "M/d"). This assumes the
     * short date pattern uses a full year ("yyyy") and the culture's date
     * separator ("/") immediately before or after the year. It tries to
     * subtract out these elements to produce a valid format without a year.
     */
    _abbreviatedDatePattern: function() {
        
        var calendar = this.culture().calendar;
        var shortPattern = calendar.patterns.d;
        var separator = calendar[ "/" ];
        var fullYearPlaceholder = "yyyy";
        
        // Try removing separator + year first, then try year + separator.
        var abbreviatedPattern;
        var separatorThenYear = separator + fullYearPlaceholder;
        var yearThenSeparator = fullYearPlaceholder + separator;
        if ( shortPattern.indexOf( separatorThenYear ) >= 0 ) {
            abbreviatedPattern = shortPattern.replace( separatorThenYear, "" );
        } else if ( shortPattern.indexOf( yearThenSeparator ) >= 0 ) {
            abbreviatedPattern = shortPattern.replace( yearThenSeparator, "" );
        } else {
            abbreviatedPattern = null;
        }
        
        return abbreviatedPattern;
    },
    
    // Return the separator between dates.
    _dateSeparator: function() {
        var culture = this.culture();
        var calendar = culture ? culture.calendar : DateTextBox;
        return calendar[ "/" ];
    },
    
    _formatDate: function( date ) {
        var culture = this.culture();
        var formattedDate;
        if ( culture ) {
            formattedDate = Globalize.format( date, culture.calendar.patterns.d, culture );
        } else {
            formattedDate = (date.getMonth() + 1) + 
                this._dateSeparator() + date.getDate() +
                this._dateSeparator() + date.getFullYear();
        }
        return formattedDate;
    },
    
    _parseDate: function( text ) {
        var parseFn = this.culture()
            ? this._parseDateWithCulture
            : this._parseDateDefault;
        var date = parseFn.call( this, text );
        return date;
    },
    
    _parseDateWithCulture: function( text ) {
        
        var culture = this.culture();
        
        var formats = null;
        var abbreviatedDatePattern = this._abbreviatedDatePattern();
        if ( abbreviatedDatePattern ) {
            // Add our abbreviated format to all the culture's patterns.
            formats = $.map( culture.calendar.patterns, function( pattern, name ) {
                return pattern;
            });
            formats.push( abbreviatedDatePattern );
        }
        
        return Globalize.parseDate( text, formats, culture );
    },
    
    /*
     * Basic date parser.
     * Parses the given text as a date and return the result.
     * Returns null if the text couldn't be parsed.
     * 
     * This handles the formats supported by the standard Date.parse(),
     * as well as handling a short year ("1/1/12") or missing year ("1/1").
     */
    _parseDateDefault: function( text ) {
        
        var dateSeparator = this._dateSeparator();
        var parts = text.split( dateSeparator );
        var currentYear = ( new Date() ).getFullYear().toString();
        
        var munged;
        if ( parts.length === 2 ) {
            // Add on year
            munged = text + dateSeparator + currentYear;
        } else if ( parts.length === 3 && parts[2].length == 2 ) {
            // Convert short year to long year
            var fullYear = currentYear.substring(0, 2) + parts[2];
            munged = parts[0] + dateSeparator
                   + parts[1] + dateSeparator
                   + fullYear;
        } else {
            // Parse as is
            munged = text;
        }
        
        var milliseconds = Date.parse( munged );
        var date = isNaN( milliseconds )
            ? null
            : Date( milliseconds );
        return date;
    },
    
    _refresh: function() {
        var date = this.date();
        if ( !!date ) {
            var formattedDate = this._formatDate( date );
            if ( formattedDate !== this.content() ) {
                this.content( formattedDate );
            }
        }
        return this;
    }
    
});

/*
 * Class properties.
 * When Globalize is not present, these offer the U.S. English defaults.
 * See the Globalize documentation (https://github.com/jquery/globalize)
 * for details.
 */
DateTextBox.extend({
	
	"/": "/",
	
	patterns: {
        // short date pattern
		d: "M/d/yyyy",
	},
	
	twoDigitYearMax: 2029
	
});
</script>

</Control>
